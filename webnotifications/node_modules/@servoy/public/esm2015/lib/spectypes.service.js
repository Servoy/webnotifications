import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "./logger.service";
export class SpecTypesService {
    constructor(logFactory) {
        this.registeredTypes = new Map();
        this.log = logFactory.getLogger('SpecTypesService');
    }
    createType(name) {
        const classRef = this.registeredTypes.get(name);
        if (classRef) {
            return new classRef();
        }
        this.log.warn('returning just the basic custom object for  ' + name + ' none of the properties will be monitored');
        return new BaseCustomObject();
    }
    enhanceArrayType(array, iterableDiffers) {
        if (!instanceOfChangeAwareValue(array)) {
            array['stateHolder'] = new ArrayState(array, iterableDiffers);
            Object.defineProperty(array, 'getStateHolder', {
                enumerable: false,
                value() {
                    return this.stateHolder;
                }
            });
            Object.defineProperty(array, 'markForChanged', {
                enumerable: false,
                value() {
                    this.stateHolder.notifyChangeListener();
                }
            });
            array['stateHolder'].initDiffer();
        }
        return array;
    }
    registerType(name, classRef) {
        this.registeredTypes.set(name, classRef);
    }
    guessType(val) {
        let guess = null;
        if (instanceOfCustomArray(val)) {
            guess = 'JSON_arr';
        }
        else if (instanceOfBaseCustomObject(val)) {
            guess = 'JSON_obj';
        } // else TODO do any other types need guessing?
        //        else { // try to find it in types?
        //            this.registeredTypes.forEach(function(typeConstructorValue, typeNameKey) {
        //                if (val instanceof typeConstructorValue) guess = typeNameKey; // this wouldn't return the converter name like 'JSON_obj' but rather the actual name from spec
        //                of the custom type like "(...).tab"
        //            });
        //        }
        return guess;
    }
}
SpecTypesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SpecTypesService, deps: [{ token: i1.LoggerFactory }], target: i0.ɵɵFactoryTarget.Injectable });
SpecTypesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SpecTypesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SpecTypesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.LoggerFactory }]; } });
export function isChanged(now, prev, conversionInfo) {
    if ((typeof conversionInfo === 'string' || typeof conversionInfo === 'number') && instanceOfChangeAwareValue(now)) {
        return now.getStateHolder().hasChanges();
    }
    if (now === prev)
        return false;
    if (now && prev) {
        if (now instanceof Array) {
            if (prev instanceof Array) {
                if (now.length !== prev.length)
                    return true;
            }
            else {
                return true;
            }
        }
        if (now instanceof Date) {
            if (prev instanceof Date) {
                return now.getTime() !== prev.getTime();
            }
            return true;
        }
        if ((now instanceof Object) && (prev instanceof Object)) {
            // first build up a list of all the properties both have.
            const fulllist = this.getCombinedPropertyNames(now, prev);
            for (const prop in fulllist) {
                // ng repeat creates a child scope for each element in the array any scope has a $$hashKey property which must be ignored since it is not part of the model
                if (prev[prop] !== now[prop]) {
                    if (prop === '$$hashKey')
                        continue;
                    if (typeof now[prop] === 'object') {
                        if (isChanged(now[prop], prev[prop], conversionInfo ? conversionInfo[prop] : undefined)) {
                            return true;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    return true;
}
export const instanceOfChangeAwareValue = (obj) => obj != null && (obj).getStateHolder instanceof Function;
export const instanceOfCustomArray = (obj) => instanceOfChangeAwareValue(obj) && obj.markForChanged instanceof Function;
export const instanceOfBaseCustomObject = (obj) => instanceOfChangeAwareValue(obj) && (obj).getStateHolder() instanceof BaseCustomObjectState;
export var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["ROWS_CHANGED"] = 0] = "ROWS_CHANGED";
    /**
     * When an INSERT happened but viewport size remained the same, it is
     * possible that some of the rows that were previously at the end of the viewport
     * slided out of it;
     * NOTE: insert signifies an insert into the client viewport, not necessarily
     * an insert in the foundset itself; for example calling "loadExtraRecordsAsync"
     * can result in an insert notification + bigger viewport size notification
     */
    ChangeType[ChangeType["ROWS_INSERTED"] = 1] = "ROWS_INSERTED";
    /**
     * When a DELETE happened inside the viewport but there were more rows available in the
     * foundset after current viewport, it is possible that some of those rows
     * slided into the viewport;
     * NOTE: delete signifies a delete from the client viewport, not necessarily
     * a delete in the foundset itself; for example calling "loadLessRecordsAsync" can
     * result in a delete notification + smaller viewport size notification
     */
    ChangeType[ChangeType["ROWS_DELETED"] = 2] = "ROWS_DELETED";
})(ChangeType || (ChangeType = {}));
export class BaseCustomObject {
    constructor() {
        this.state = new BaseCustomObjectState();
        this.state.allChanged = true;
    }
    getStateHolder() {
        return this.state;
    }
    /**
     *  subclasses can override this to give back the properties that needs to be watched.
     */
    getWatchedProperties() {
        return null;
    }
}
;
export class ChangeAwareState {
    constructor() {
        this.allChanged = false;
        this.inNotify = false;
    }
    markAllChanged(notifyListener) {
        this.allChanged = true;
        if (notifyListener)
            this.notifyChangeListener();
    }
    hasChanges() {
        return this.allChanged || this.inNotify;
    }
    setChangeListener(callback) {
        this.changeListener = callback;
    }
    notifyChangeListener() {
        this.inNotify = true;
        if (this.changeListener)
            this.changeListener();
        this.inNotify = false;
    }
}
export class BaseCustomObjectState extends ChangeAwareState {
    constructor() {
        super(...arguments);
        this.conversionInfo = {};
        this.ignoreChanges = false;
        this.change = 0;
        this.hash = BaseCustomObjectState.counter++;
        this.changedKeys = new Set();
    }
    hasChanges() {
        return super.hasChanges() || this.getChangedKeys().size > 0; // leave this as a method call as some subclasses might compute the changedKeys inside getChangedKeys()
    }
    setPropertyAndHandleChanges(_thisBaseCustoomObject, internalPropertyName, propertyName, value) {
        const oldValue = _thisBaseCustoomObject[internalPropertyName];
        // if the value of this property is changed, mark it as such and notify if needed
        this.markIfChanged(propertyName, value, oldValue);
        // unregister as listener to old value if needed
        this.setChangeListenerToSubValueIfNeeded(oldValue, undefined);
        _thisBaseCustoomObject[internalPropertyName] = value;
        // register as listener to new value if needed
        this.setChangeListenerToSubValueIfNeeded(value, () => {
            this.markIfChanged(propertyName, value, value);
        });
        // this value has changed by reference; so it needs to be fully sent to server - except for when it now arrived from the server and is being set (in which case ignoreChanges is true)
        if (!this.ignoreChanges && instanceOfChangeAwareValue(value))
            value.getStateHolder().markAllChanged(false);
    }
    getChangedKeys() {
        return this.changedKeys;
    }
    clearChanges() {
        this.changedKeys.clear();
        this.allChanged = false;
    }
    getHashKey() {
        return this.hash + '_' + this.change;
    }
    markIfChanged(propertyName, newObject, oldObject) {
        if (this.testChanged(propertyName, newObject, oldObject)) {
            this.pushChange(propertyName);
            return true;
        }
        return false;
    }
    setChangeListenerToSubValueIfNeeded(value, changeListener) {
        if (instanceOfChangeAwareValue(value)) {
            // child is able to handle it's own change mechanism
            value.getStateHolder().setChangeListener(changeListener);
        }
    }
    pushChange(propertyName) {
        if (this.ignoreChanges)
            return;
        if (this.changedKeys.size === 0)
            this.change++;
        if (!this.changedKeys.has(propertyName)) {
            this.changedKeys.add(propertyName);
            this.notifyChangeListener();
        }
    }
    testChanged(propertyName, newObject, oldObject) {
        if (newObject !== oldObject)
            return true;
        if (typeof newObject == 'object') {
            if (instanceOfChangeAwareValue(newObject)) {
                return newObject.getStateHolder().hasChanges();
            }
            else {
                return isChanged(newObject, oldObject, this.conversionInfo[propertyName]);
            }
        }
        return false;
    }
}
// provide a hash that lets arrays that contain custom objects know that the object has changed or not
BaseCustomObjectState.counter = 0;
export class ArrayState extends BaseCustomObjectState {
    constructor(array, iterableDiffers) {
        super();
        this.array = array;
        this.iterableDiffers = iterableDiffers;
        this.allChanged = true;
    }
    initDiffer() {
        this.differ = this.iterableDiffers.find(this.array).create((index, item) => {
            if (instanceOfBaseCustomObject(item)) {
                return item.getStateHolder().getHashKey();
            }
            return item;
        });
        this.differ.diff(this.array);
    }
    clearChanges() {
        super.clearChanges();
        this.initDiffer();
    }
    getChangedKeys() {
        let changes = super.getChangedKeys();
        const arrayChanges = this.differ.diff(this.array);
        if (arrayChanges) {
            let addedOrRemoved = 0;
            arrayChanges.forEachAddedItem((record) => {
                addedOrRemoved++;
                changes.add(record.currentIndex);
            });
            arrayChanges.forEachRemovedItem((record) => {
                addedOrRemoved--;
                changes.add(record.previousIndex);
            });
            arrayChanges.forEachMovedItem((record) => {
                if (instanceOfChangeAwareValue(record.item)) {
                    return record.item.getStateHolder().markAllChanged(false);
                }
            });
            if (addedOrRemoved !== 0) {
                // size changed, for now send whole array
                this.markAllChanged(false);
            }
            else {
                const changesArray = Array.from(changes);
                changesArray.sort((a, b) => a - b);
                changes = new Set(changesArray);
            }
        }
        return changes;
    }
}
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BlY3R5cGVzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zZXJ2b3ktcHVibGljL3NyYy9saWIvc3BlY3R5cGVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0FBVTNDLE1BQU0sT0FBTyxnQkFBZ0I7SUFLekIsWUFBWSxVQUF5QjtRQUg3QixvQkFBZSxHQUFHLElBQUksR0FBRyxFQUFtQyxDQUFDO1FBSWpFLElBQUksQ0FBQyxHQUFHLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFDRCxVQUFVLENBQUMsSUFBWTtRQUNuQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRCxJQUFJLFFBQVEsRUFBRTtZQUNWLE9BQU8sSUFBSSxRQUFRLEVBQUUsQ0FBQztTQUN6QjtRQUNELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxHQUFHLElBQUksR0FBRywyQ0FBMkMsQ0FBQyxDQUFDO1FBQ25ILE9BQU8sSUFBSSxnQkFBZ0IsRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxnQkFBZ0IsQ0FBSSxLQUFlLEVBQUUsZUFBZ0M7UUFDakUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3BDLEtBQUssQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDOUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBQzNDLFVBQVUsRUFBRSxLQUFLO2dCQUNqQixLQUFLO29CQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztnQkFDNUIsQ0FBQzthQUNKLENBQUMs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Q0FBQztnQkFDakIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDckMsQ0FBQyxDQUFDLENBQUM7WUFDSCxZQUFZLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtnQkFDdkMsY0FBYyxFQUFFLENBQUM7Z0JBQ2pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3RDLENBQUMsQ0FBQyxDQUFDO1lBRUgsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ3JDLElBQUksMEJBQTBCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUN6QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUM3RDtZQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxjQUFjLEtBQUssQ0FBQyxFQUFFO2dCQUN0Qix5Q0FBeUM7Z0JBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDOUI7aUJBQU07Z0JBQ0gsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDekMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDbkQsT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ25DO1NBQ0o7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0NBRUo7QUFNQSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgSXRlcmFibGVEaWZmZXJzLCBJdGVyYWJsZURpZmZlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IExvZ2dlckZhY3RvcnksIExvZ2dlclNlcnZpY2UgfSBmcm9tICcuL2xvZ2dlci5zZXJ2aWNlJztcclxuXHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTcGVjVHlwZXNTZXJ2aWNlIHtcclxuXHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyZWRUeXBlcyA9IG5ldyBNYXA8c3RyaW5nLCB0eXBlb2YgQmFzZUN1c3RvbU9iamVjdD4oKTtcclxuICAgIHByaXZhdGUgbG9nOiBMb2dnZXJTZXJ2aWNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxvZ0ZhY3Rvcnk6IExvZ2dlckZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLmxvZyA9IGxvZ0ZhY3RvcnkuZ2V0TG9nZ2VyKCdTcGVjVHlwZXNTZXJ2aWNlJyk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVUeXBlKG5hbWU6IHN0cmluZyk6IEJhc2VDdXN0b21PYmplY3Qge1xyXG4gICAgICAgIGNvbnN0IGNsYXNzUmVmID0gdGhpcy5yZWdpc3RlcmVkVHlwZXMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChjbGFzc1JlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNsYXNzUmVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JldHVybmluZyBqdXN0IHRoZSBiYXNpYyBjdXN0b20gb2JqZWN0IGZvciAgJyArIG5hbWUgKyAnIG5vbmUgb2YgdGhlIHByb3BlcnRpZXMgd2lsbCBiZSBtb25pdG9yZWQnKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJhc2VDdXN0b21PYmplY3QoKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmhhbmNlQXJyYXlUeXBlPFQ+KGFycmF5OiBBcnJheTxUPiwgaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMpOiBJQ3VzdG9tQXJyYXk8VD4ge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2VPZkNoYW5nZUF3YXJlVmFsdWUoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIGFycmF5WydzdGF0ZUhvbGRlciddID0gbmV3IEFycmF5U3RhdGUoYXJyYXksIGl0ZXJhYmxlRGlmZmVycyk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ2dldFN0YXRlSG9sZGVyJywge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVIb2xkZXI7XG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnbWFya0ZvckNoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlSG9sZGVyLm5vdGlmeUNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXJyYXlbJ3N0YXRlSG9sZGVyJ10uaW5pdERpZmZlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXkgYXMgSUN1c3RvbUFycmF5PFQ+O1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyVHlwZShuYW1lOiBzdHJpbmcsIGNsYXNzUmVmOiB0eXBlb2YgQmFzZUN1c3RvbU9iamVjdCkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFR5cGVzLnNldChuYW1lLCBjbGFzc1JlZik7XHJcbiAgICB9XHJcblxyXG4gICAgZ3Vlc3NUeXBlKHZhbDogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgZ3Vlc3MgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoaW5zdGFuY2VPZkN1c3RvbUFycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgZ3Vlc3MgPSAnSlNPTl9hcnInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2VPZkJhc2VDdXN0b21PYmplY3QodmFsKSkge1xyXG4gICAgICAgICAgICBndWVzcyA9ICdKU09OX29iaic7XHJcbiAgICAgICAgfSAvLyBlbHNlIFRPRE8gZG8gYW55IG90aGVyIHR5cGVzIG5lZWQgZ3Vlc3Npbmc/XHJcbiAgICAgICAgLy8gICAgICAgIGVsc2UgeyAvLyB0cnkgdG8gZmluZCBpdCBpbiB0eXBlcz9cclxuICAgICAgICAvLyAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZFR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZUNvbnN0cnVjdG9yVmFsdWUsIHR5cGVOYW1lS2V5KSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIHR5cGVDb25zdHJ1Y3RvclZhbHVlKSBndWVzcyA9IHR5cGVOYW1lS2V5OyAvLyB0aGlzIHdvdWxkbid0IHJldHVybiB0aGUgY29udmVydGVyIG5hbWUgbGlrZSAnSlNPTl9vYmonIGJ1dCByYXRoZXIgdGhlIGFjdHVhbCBuYW1lIGZyb20gc3BlY1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIG9mIHRoZSBjdXN0b20gdHlwZSBsaWtlIFwiKC4uLikudGFiXCJcclxuICAgICAgICAvLyAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGd1ZXNzO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNDaGFuZ2VkKG5vdywgcHJldiwgY29udmVyc2lvbkluZm8pIHtcclxuICAgIGlmICgodHlwZW9mIGNvbnZlcnNpb25JbmZvID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29udmVyc2lvbkluZm8gPT09ICdudW1iZXInKSAmJiBpbnN0YW5jZU9mQ2hhbmdlQXdhcmVWYWx1ZShub3cpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vdy5nZXRTdGF0ZUhvbGRlcigpLmhhc0NoYW5nZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm93ID09PSBwcmV2KSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAobm93ICYmIHByZXYpIHtcclxuICAgICAgICBpZiAobm93IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKHByZXYgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vdy5sZW5ndGggIT09IHByZXYubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub3cgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdy5nZXRUaW1lKCkgIT09IHByZXYuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChub3cgaW5zdGFuY2VvZiBPYmplY3QpICYmIChwcmV2IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAvLyBmaXJzdCBidWlsZCB1cCBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzIGJvdGggaGF2ZS5cclxuICAgICAgICAgICAgY29uc3QgZnVsbGxpc3QgPSB0aGlzLmdldENvbWJpbmVkUHJvcGVydHlOYW1lcyhub3csIHByZXYpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZnVsbGxpc3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5nIHJlcGVhdCBjcmVhdGVzIGEgY2hpbGQgc2NvcGUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgYW55IHNjb3BlIGhhcyBhICQkaGFzaEtleSBwcm9wZXJ0eSB3aGljaCBtdXN0IGJlIGlnbm9yZWQgc2luY2UgaXQgaXMgbm90IHBhcnQgb2YgdGhlIG1vZGVsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldltwcm9wXSAhPT0gbm93W3Byb3BdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICckJGhhc2hLZXknKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vd1twcm9wXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZChub3dbcHJvcF0sIHByZXZbcHJvcF0sIGNvbnZlcnNpb25JbmZvID8gY29udmVyc2lvbkluZm9bcHJvcF0gOiB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBpbnN0YW5jZU9mQ2hhbmdlQXdhcmVWYWx1ZSA9IChvYmo6IGFueSk6IG9iaiBpcyBJQ2hhbmdlQXdhcmVWYWx1ZSA9PlxyXG4gICAgb2JqICE9IG51bGwgJiYgKG9iaikuZ2V0U3RhdGVIb2xkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgaW5zdGFuY2VPZkN1c3RvbUFycmF5ID0gPFQ+KG9iajogYW55KTogb2JqIGlzIElDdXN0b21BcnJheTxUPiA9PlxyXG4gICAgaW5zdGFuY2VPZkNoYW5nZUF3YXJlVmFsdWUob2JqKSAmJiAob2JqIGFzIElDdXN0b21BcnJheTxUPikubWFya0ZvckNoYW5nZWQgaW5zdGFuY2VvZiBGdW5jdGlvbjtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgaW5zdGFuY2VPZkJhc2VDdXN0b21PYmplY3QgPSAob2JqOiBhbnkpOiBvYmogaXMgQmFzZUN1c3RvbU9iamVjdCA9PlxyXG4gICAgaW5zdGFuY2VPZkNoYW5nZUF3YXJlVmFsdWUob2JqKSAmJiAob2JqKS5nZXRTdGF0ZUhvbGRlcigpIGluc3RhbmNlb2YgQmFzZUN1c3RvbU9iamVjdFN0YXRlO1xyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNoYW5nZUF3YXJlVmFsdWUge1xyXG4gICAgZ2V0U3RhdGVIb2xkZXIoKTogQ2hhbmdlQXdhcmVTdGF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQ3VzdG9tT2JqZWN0IGV4dGVuZHMgSUNoYW5nZUF3YXJlVmFsdWUge1xyXG4gICAgZ2V0U3RhdGVIb2xkZXIoKTogQmFzZUN1c3RvbU9iamVjdFN0YXRlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElDdXN0b21BcnJheTxUPiBleHRlbmRzIEFycmF5PFQ+LCBJQ2hhbmdlQXdhcmVWYWx1ZSB7XHJcbiAgICBnZXRTdGF0ZUhvbGRlcigpOiBBcnJheVN0YXRlO1xyXG4gICAgbWFya0ZvckNoYW5nZWQoKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJVmFsdWVsaXN0IGV4dGVuZHMgQXJyYXk8eyBkaXNwbGF5VmFsdWU6IHN0cmluZzsgcmVhbFZhbHVlOiBhbnkgfT4ge1xyXG4gICAgZmlsdGVyTGlzdChmaWx0ZXJTdHJpbmc6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PjtcclxuICAgIGdldERpc3BsYXlWYWx1ZShyZWFsVmFsdWU6IGFueSk6IE9ic2VydmFibGU8YW55PjtcclxuICAgIGhhc1JlYWxWYWx1ZXMoKTogYm9vbGVhbjtcclxuICAgIGlzUmVhbFZhbHVlRGF0ZSgpOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElGb3VuZHNldEZpZWxkc09ubHkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaWRlbnRpZmllciB0aGF0IGFsbG93cyB5b3UgdG8gdXNlIHRoaXMgZm91bmRzZXQgdmlhIHRoZSAnZm91bmRzZXRSZWYnIHR5cGU7XHJcbiAgICAgKiB3aGVuIGEgJ2ZvdW5kc2V0UmVmJyB0eXBlIHNlbmRzIGEgZm91bmRzZXQgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50IChmb3IgZXhhbXBsZVxyXG4gICAgICogYXMgYSByZXR1cm4gdmFsdWUgb2YgY2FsbFNlcnZlclNpZGVBcGkpIGl0IHdpbGwgdHJhbnNsYXRlIHRvIHRoaXMgaWRlbnRpZmllclxyXG4gICAgICogb24gY2xpZW50IChzbyB5b3UgY2FuIHVzZSBpdCB0byBmaW5kIHRoZSBhY3R1YWwgZm91bmRzZXQgcHJvcGVydHkgaW4gdGhlIG1vZGVsIGlmXHJcbiAgICAgKiBzZXJ2ZXIgc2lkZSBzY3JpcHQgcHV0IGl0IGluIHRoZSBtb2RlbCBhcyB3ZWxsKTsgaW50ZXJuYWxseSB3aGVuIHNlbmRpbmcgYVxyXG4gICAgICogJ2ZvdW5kc2V0JyB0eXBlZCBwcm9wZXJ0eSB0byBzZXJ2ZXIgdGhyb3VnaCBhICdmb3VuZHNldFJlZicgdHlwZWQgYXJndW1lbnQgb3IgcHJvcCxcclxuICAgICAqIGl0IHdpbGwgdXNlIHRoaXMgZm91bmRzZXRJZCBhcyB3ZWxsIHRvIGZpbmQgaXQgb24gc2VydmVyIGFuZCBnaXZlIGEgcmVhbCBGb3VuZHNldFxyXG4gICAgICovXHJcbiAgICBmb3VuZHNldElkOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgc2l6ZSBvZiB0aGUgZm91bmRzZXQgb24gc2VydmVyIChzbyBub3QgbmVjZXNzYXJpbHkgdGhlIHRvdGFsIHJlY29yZCBjb3VudFxyXG4gICAgICogaW4gY2FzZSBvZiBsYXJnZSBEQiB0YWJsZXMpXHJcbiAgICAgKi9cclxuICAgIHNlcnZlclNpemU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoaXMgaXMgdGhlIGRhdGEgeW91IG5lZWQgdG8gaGF2ZSBsb2FkZWQgb24gY2xpZW50IChqdXN0IHJlcXVlc3Qgd2hhdCB5b3UgbmVlZCB2aWEgcHJvdmlkZWRcclxuICAgICAqIGxvYWRSZWNvcmRzQXN5bmMgb3IgbG9hZEV4dHJhUmVjb3Jkc0FzeW5jKVxyXG4gICAgICovXHJcbiAgICB2aWV3UG9ydDogVmlld1BvcnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBhcnJheSBvZiBzZWxlY3RlZCByZWNvcmRzIGluIGZvdW5kc2V0OyBpbmRleGVzIGNhbiBiZSBvdXQgb2YgY3VycmVudFxyXG4gICAgICogdmlld1BvcnQgYXMgd2VsbFxyXG4gICAgICovXHJcbiAgICBzZWxlY3RlZFJvd0luZGV4ZXM6IG51bWJlcltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc29ydCBzdHJpbmcgb2YgdGhlIGZvdW5kc2V0LCB0aGUgc2FtZSBhcyB0aGUgb25lIHVzZWQgaW4gc2NyaXB0aW5nIGZvclxyXG4gICAgICogZm91bmRzZXQuc29ydCBhbmQgZm91bmRzZXQuZ2V0Q3VycmVudFNvcnQuIEV4YW1wbGU6ICdvcmRlcmlkIGFzYycuXHJcbiAgICAgKi9cclxuICAgIHNvcnRDb2x1bW5zOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0aGUgbXVsdGlzZWxlY3QgbW9kZSBvZiB0aGUgc2VydmVyJ3MgZm91bmRzZXQ7IGlmIHRoaXMgaXMgZmFsc2UsXHJcbiAgICAgKiBzZWxlY3RlZFJvd0luZGV4ZXMgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBpbiBpdFxyXG4gICAgICovXHJcbiAgICBtdWx0aVNlbGVjdDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGlmIHRoZSBmb3VuZHNldCBpcyBsYXJnZSBhbmQgb24gc2VydmVyLXNpZGUgb25seSBwYXJ0IG9mIGl0IGlzIGxvYWRlZCAoc29cclxuICAgICAqIHRoZXJlIGFyZSByZWNvcmRzIGluIHRoZSBmb3VuZHNldCBiZXlvbmQgJ3NlcnZlclNpemUnKSB0aGlzIGlzIHNldCB0byB0cnVlO1xyXG4gICAgICogaW4gdGhpcyB3YXkgeW91IGtub3cgeW91IGNhbiBsb2FkIHJlY29yZHMgZXZlbiBhZnRlciAnc2VydmVyU2l6ZScgKHJlcXVlc3RpbmdcclxuICAgICAqIHZpZXdwb3J0IHRvIGxvYWQgcmVjb3JkcyBhdCBpbmRleCBzZXJ2ZXJTaXplLTEgb3IgZ3JlYXRlciB3aWxsIGxvYWQgbW9yZVxyXG4gICAgICogcmVjb3JkcyBpbiB0aGUgZm91bmRzZXQpXHJcbiAgICAgKi9cclxuICAgIGhhc01vcmVSb3dzOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogY29sdW1uRm9ybWF0cyBpcyBvbmx5IHByZXNlbnQgaWYgeW91IHNwZWNpZnlcclxuICAgICAqIFwicHJvdmlkZUNvbHVtbkZvcm1hdHNcIjogdHJ1ZSBpbnNpZGUgdGhlIC5zcGVjIGZpbGUgZm9yIHRoaXMgZm91bmRzZXQgcHJvcGVydHk7XHJcbiAgICAgKiBpdCBnaXZlcyB0aGUgZGVmYXVsdCBjb2x1bW4gZm9ybWF0dGluZyB0aGF0IFNlcnZveSB3b3VsZCBub3JtYWxseSB1c2UgZm9yXHJcbiAgICAgKiBlYWNoIGNvbHVtbiBvZiB0aGUgdmlld3BvcnQgLSB3aGljaCB5b3UgY2FuIHRoZW4gYWxzbyB1c2UgaW4gdGhlXHJcbiAgICAgKiBicm93c2VyIHlvdXJzZWxmOyBrZXlzIGFyZSB0aGUgZGF0YXByb3ZpZGVyIG5hbWVzIGFuZCB2YWx1ZXMgYXJlIG9iamVjdHMgdGhhdCBjb250YWluXHJcbiAgICAgKiB0aGUgZm9ybWF0IGNvbnRlbnRzXHJcbiAgICAgKi9cclxuICAgIGNvbHVtbkZvcm1hdHM6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUZvdW5kc2V0IGV4dGVuZHMgSUZvdW5kc2V0RmllbGRzT25seSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0IGEgY2hhbmdlIG9mIHZpZXdwb3J0IGJvdW5kcyBmcm9tIHRoZSBzZXJ2ZXI7IHRoZSByZXF1ZXN0ZWQgZGF0YSB3aWxsIGJlIGxvYWRlZFxyXG4gICAgICogYXN5bmNocm9ub3VzbHkgaW4gJ3ZpZXdQb3J0J1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IHRoZSBpbmRleCB0aGF0IHlvdSByZXF1ZXN0IHRoZSBmaXJzdCByZWNvcmQgaW4gXCJ2aWV3UG9ydC5yb3dzXCIgdG8gaGF2ZSBpblxyXG4gICAgICogICAgICAgICAgICAgICAgICAgdGhlIHJlYWwgZm91bmRzZXQgKHNvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHZpZXdQb3J0KS5cclxuICAgICAqIEBwYXJhbSBzaXplIHRoZSBudW1iZXIgb2YgcmVjb3JkcyB0byBsb2FkIGluIHZpZXdQb3J0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBnZXQgcmVzb2x2ZWQgd2hlbiB0aGUgcmVxdWVzdGVkIHJlY29yZHMgYXJyaXZlZCBicm93c2VyLVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgc2lkZS4gQXMgd2l0aCBhbnkgcHJvbWlzZSB5b3UgY2FuIHJlZ2lzdGVyIHN1Y2Nlc3MsIGVycm9yIGNhbGxiYWNrcywgZmluYWxseSwgLi4uXHJcbiAgICAgKi9cclxuICAgIGxvYWRSZWNvcmRzQXN5bmMoc3RhcnRJbmRleDogbnVtYmVyLCBzaXplOiBudW1iZXIpOiBQcm9taXNlPGFueT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0IG1vcmUgcmVjb3JkcyBmb3IgeW91ciB2aWV3UG9ydDsgaWYgdGhlIGFyZ3VtZW50IGlzIHBvc2l0aXZlIG1vcmUgcmVjb3JkcyB3aWxsIGJlXHJcbiAgICAgKiBsb2FkZWQgYXQgdGhlIGVuZCBvZiB0aGUgJ3ZpZXdQb3J0Jywgd2hlbiBuZWdhdGl2ZSBtb3JlIHJlY29yZHMgd2lsbCBiZSBsb2FkZWQgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICogb2YgdGhlICd2aWV3UG9ydCcgLSBhc3luY2hyb25vdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmVnYXRpdmVPclBvc2l0aXZlQ291bnQgdGhlIG51bWJlciBvZiByZWNvcmRzIHRvIGV4dGVuZCB0aGUgdmlld1BvcnQucm93cyB3aXRoIGJlZm9yZSBvclxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBjdXJyZW50bHkgbG9hZGVkIHJlY29yZHMuXHJcbiAgICAgKiBAcGFyYW0gZG9udE5vdGlmeVlldCBpZiB5b3Ugc2V0IHRoaXMgdG8gdHJ1ZSwgdGhlbiB0aGUgbG9hZCByZXF1ZXN0IHdpbGwgbm90IGJlIHNlbnQgdG8gc2VydmVyXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICByaWdodCBhd2F5LiBTbyB5b3UgY2FuIHF1ZXVlIG11bHRpcGxlIGxvYWRMZXNzL2xvYWRFeHRyYSBiZWZvcmUgc2VuZGluZyB0aGVtXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB0byBzZXJ2ZXIuIElmIGZhbHNlL3VuZGVmaW5lZCBpdCB3aWxsIHNlbmQgdGhpcyAoYW5kIGFueSBwcmV2aW91c2x5IHF1ZXVlZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCkgdG8gc2VydmVyLiBTZWUgYWxzbyBub3RpZnlDaGFuZ2VkKCkuIFNlZSBhbHNvIG5vdGlmeUNoYW5nZWQoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZ2V0IHJlc29sdmVkIHdoZW4gdGhlIHJlcXVlc3RlZCByZWNvcmRzIGFycml2ZWQgYnJvd3Nlci1cclxuICAgICAqICAgICAgICAgICAgICAgICAgIHNpZGUuIEFzIHdpdGggYW55IHByb21pc2UgeW91IGNhbiByZWdpc3RlciBzdWNjZXNzLCBlcnJvciBjYWxsYmFja3MsIGZpbmFsbHksIC4uLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgVGhhdCBhbGxvd3MgY3VzdG9tIGNvbXBvbmVudCB0byBtYWtlIHN1cmUgdGhhdCBsb2FkRXh0cmEvbG9hZExlc3MgY2FsbHMgZnJvbVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgY2xpZW50IGRvIG5vdCBzdGFjayBvbiBub3QgeWV0IHVwZGF0ZWQgdmlld3BvcnRzIHRvIHJlc3VsdCBpbiB3cm9uZyBib3VuZHMuXHJcbiAgICAgKi9cclxuICAgIGxvYWRFeHRyYVJlY29yZHNBc3luYyhuZWdhdGl2ZU9yUG9zaXRpdmVDb3VudDogbnVtYmVyLCBkb250Tm90aWZ5WWV0PzogYm9vbGVhbik6IFByb21pc2U8YW55PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgYSBzaHJpbmsgb2YgdGhlIHZpZXdwb3J0OyBpZiB0aGUgYXJndW1lbnQgaXMgcG9zaXRpdmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgdmlld3BvcnQgd2lsbFxyXG4gICAgICogc2hyaW5rLCB3aGVuIGl0IGlzIG5lZ2F0aXZlIHRoZW4gdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQgd2lsbCBzaHJpbmsgLSBhc3luY2hyb25vdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmVnYXRpdmVPclBvc2l0aXZlQ291bnQgdGhlIG51bWJlciBvZiByZWNvcmRzIHRvIHNocmluayB0aGUgdmlld1BvcnQucm93cyBieSBiZWZvcmUgb3JcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgY3VycmVudGx5IGxvYWRlZCByZWNvcmRzLlxyXG4gICAgICogQHBhcmFtIGRvbnROb3RpZnlZZXQgaWYgeW91IHNldCB0aGlzIHRvIHRydWUsIHRoZW4gdGhlIGxvYWQgcmVxdWVzdCB3aWxsIG5vdCBiZSBzZW50IHRvIHNlcnZlclxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgcmlnaHQgYXdheS4gU28geW91IGNhbiBxdWV1ZSBtdWx0aXBsZSBsb2FkTGVzcy9sb2FkRXh0cmEgYmVmb3JlIHNlbmRpbmcgdGhlbVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgdG8gc2VydmVyLiBJZiBmYWxzZS91bmRlZmluZWQgaXQgd2lsbCBzZW5kIHRoaXMgKGFuZCBhbnkgcHJldmlvdXNseSBxdWV1ZWRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QpIHRvIHNlcnZlci4gU2VlIGFsc28gbm90aWZ5Q2hhbmdlZCgpLiBTZWUgYWxzbyBub3RpZnlDaGFuZ2VkKCkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGdldCByZXNvbHZlZCB3aGVuIHRoZSByZXF1ZXN0ZWQgcmVjb3JkcyBhcnJpdmVkIGJyb3dzZXJcclxuICAgICAqICAgICAgICAgICAgICAgICAgIC1zaWRlLiBBcyB3aXRoIGFueSBwcm9taXNlIHlvdSBjYW4gcmVnaXN0ZXIgc3VjY2VzcywgZXJyb3IgY2FsbGJhY2tzLCBmaW5hbGx5LCAuLi5cclxuICAgICAqICAgICAgICAgICAgICAgICAgIFRoYXQgYWxsb3dzIGN1c3RvbSBjb21wb25lbnQgdG8gbWFrZSBzdXJlIHRoYXQgbG9hZEV4dHJhL2xvYWRMZXNzIGNhbGxzIGZyb21cclxuICAgICAqICAgICAgICAgICAgICAgICAgIGNsaWVudCBkbyBub3Qgc3RhY2sgb24gbm90IHlldCB1cGRhdGVkIHZpZXdwb3J0cyB0byByZXN1bHQgaW4gd3JvbmcgYm91bmRzLlxyXG4gICAgICovXHJcbiAgICBsb2FkTGVzc1JlY29yZHNBc3luYyhuZWdhdGl2ZU9yUG9zaXRpdmVDb3VudDogbnVtYmVyLCBkb250Tm90aWZ5WWV0PzogYm9vbGVhbik6IFByb21pc2U8YW55PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHlvdSBxdWV1ZSBtdWx0aXBsZSBsb2FkRXh0cmFSZWNvcmRzQXN5bmMgYW5kIGxvYWRMZXNzUmVjb3Jkc0FzeW5jIGJ5IHVzaW5nIGRvbnROb3RpZnlZZXQgPSB0cnVlXHJcbiAgICAgKiB0aGVuIHlvdSBjYW4gLSBpbiB0aGUgZW5kIC0gc2VuZCBhbGwgdGhlc2UgcmVxdWVzdHMgdG8gc2VydmVyIChpZiBhbnkgYXJlIHF1ZXVlZCkgYnkgY2FsbGluZ1xyXG4gICAgICogdGhpcyBtZXRob2QuIElmIG5vIHJlcXVlc3RzIGFyZSBxdWV1ZWQsIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBoYXZlIG5vIGVmZmVjdC5cclxuICAgICAqL1xyXG4gICAgbm90aWZ5Q2hhbmdlZCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29ydCB0aGUgZm91bmRzZXQgYnkgdGhlIGRhdGFwcm92aWRlcnMvY29sdW1ucyBpZGVudGlmaWVkIGJ5IHNvcnRDb2x1bW5zLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBuYW1lIHByb3BlcnR5IG9mIGVhY2ggc29ydENvbHVtbiBjYW4gYmUgZmlsbGVkIHdpdGggdGhlIGRhdGFwcm92aWRlciBuYW1lIHRoZSBmb3VuZHNldCBwcm92aWRlc1xyXG4gICAgICogb3Igc3BlY2lmaWVzLiBJZiB0aGUgZm91bmRzZXQgaXMgdXNlZCB3aXRoIGEgY29tcG9uZW50IHR5cGUgKGxpa2UgaW4gdGFibGUtdmlldykgdGhlbiB0aGUgbmFtZSBpc1xyXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBvbiB3aG8ncyBmaXJzdCBkYXRhcHJvdmlkZXIgcHJvcGVydHkgdGhlIHNvcnQgc2hvdWxkIGhhcHBlbi4gSWYgdGhlXHJcbiAgICAgKiBmb3VuZHNldCBpcyB1c2VkIHdpdGggYW5vdGhlciBmb3VuZHNldC1saW5rZWQgcHJvcGVydHkgdHlwZSAoZGF0YXByb3ZpZGVyL3RhZ3N0cmluZyBsaW5rZWQgdG9cclxuICAgICAqIGZvdW5kc2V0cykgdGhlbiB0aGUgbmFtZSB5b3Ugc2hvdWxkIGdpdmUgaW4gdGhlIHNvcnRDb2x1bW4gaXMgdGhhdCBwcm9wZXJ0eSdzICdpZEZvckZvdW5kc2V0JyB2YWx1ZVxyXG4gICAgICogKGZvciBleGFtcGxlIGEgcmVjb3JkICdkYXRhcHJvdmlkZXInIHByb3BlcnR5IGxpbmtlZCB0byB0aGUgZm91bmRzZXQgd2lsbCBiZSBhbiBhcnJheSBvZiB2YWx1ZXNcclxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQsIGJ1dCBpdCB3aWxsIGFsc28gaGF2ZSBhICdpZEZvckZvdW5kc2V0JyBwcm9wLiB0aGF0IGNhbiBiZSB1c2VkIGZvclxyXG4gICAgICogc29ydGluZyBpbiB0aGlzIGNhbGw7IHRoaXMgJ2lkRm9yRm91bmRzZXQnIHdhcyBhZGRlZCBpbiB2ZXJzaW9uIDguMC4zKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc29ydENvbHVtbnMgYW4gYXJyYXkgb2YgSlNPTk9iamVjdHMgeyBuYW1lIDogZGF0YXByb3ZpZGVyX2lkLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA6IHNvcnREaXJlY3Rpb24gfSwgd2hlcmUgdGhlIHNvcnREaXJlY3Rpb24gY2FuIGJlIFwiYXNjXCIgb3IgXCJkZXNjXCIuXHJcbiAgICAgKiBAcmV0dXJuIChhZGRlZCBpbiBTZXJ2b3kgOC4yLjEpIGEgcHJvbWlzZSB0aGF0IHdpbGwgZ2V0IHJlc29sdmVkIHdoZW4gdGhlIG5ldyBzb3J0XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICB3aWxsIGFycml2ZSBicm93c2VyLXNpZGUuIEFzIHdpdGggYW55IHByb21pc2UgeW91IGNhbiByZWdpc3RlciBzdWNjZXNzLCBlcnJvclxyXG4gICAgICogICAgICAgICAgICAgICAgICAgYW5kIGZpbmFsbHkgY2FsbGJhY2tzLlxyXG4gICAgICovXHJcbiAgICBzb3J0KHNvcnRDb2x1bW5zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgZGlyZWN0aW9uOiAoJ2FzYycgfCAnZGVzYycpIH0+KTogUHJvbWlzZTxhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBhIHNlbGVjdGlvbiBjaGFuZ2Ugb2YgdGhlIHNlbGVjdGVkIHJvdyBpbmRleGVzLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkXHJcbiAgICAgKiB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgdGhlIHVwZGF0ZWQgc2VsZWN0aW9uIGZyb20gdGhlIHNlcnZlci4gSWYgc3VjY2Vzc2Z1bCwgdGhlIGFycmF5XHJcbiAgICAgKiBzZWxlY3RlZFJvd0luZGV4ZXMgd2lsbCBhbHNvIGJlIHVwZGF0ZWQuIElmIHRoZSBzZXJ2ZXIgZG9lcyBub3QgYWxsb3cgdGhlIHNlbGVjdGlvbiBjaGFuZ2UsXHJcbiAgICAgKiB0aGUgcmVqZWN0IGZ1bmN0aW9uIHdpbGwgZ2V0IGNhbGxlZCB3aXRoIHRoZSAnb2xkJyBzZWxlY3Rpb24gYXMgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIElmIHJlcXVlc3RTZWxlY3Rpb25VcGRhdGUgaXMgY2FsbGVkIGEgc2Vjb25kIHRpbWUsIGJlZm9yZSB0aGUgZmlyc3QgY2FsbCBpcyByZXNvbHZlZCwgdGhlXHJcbiAgICAgKiBmaXJzdCBjYWxsIHdpbGwgYmUgcmVqZWN0ZWQgYW5kIHRoZSBjYWxsZXIgd2lsbCByZWNlaXZlIHRoZSBzdHJpbmcgJ2NhbmNlbGVkJyBhcyB0aGUgdmFsdWVcclxuICAgICAqIGZvciB0aGUgcGFyYW1ldGVyIHNlcnZlclJvd3MuXHJcbiAgICAgKiBFLmcuOiBmb3VuZHNldC5yZXF1ZXN0U2VsZWN0aW9uVXBkYXRlKFsyLDMsNF0pLnRoZW4oZnVuY3Rpb24oc2VydmVyUm93cyl7fSxmdW5jdGlvbihzZXJ2ZXJSb3dzKXt9KTtcclxuICAgICAqL1xyXG4gICAgcmVxdWVzdFNlbGVjdGlvblVwZGF0ZShzZWxlY3RlZFJvd0lkeHM6IG51bWJlcltdKTogUHJvbWlzZTxhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcHJlZmVycmVkIHZpZXdQb3J0IG9wdGlvbnMgaGludCBvbiB0aGUgc2VydmVyIGZvciB0aGlzIGZvdW5kc2V0LCBzbyB0aGF0IHRoZSBuZXh0XHJcbiAgICAgKiAoaW5pdGlhbCBvciBuZXcpIGxvYWQgd2lsbCBhdXRvbWF0aWNhbGx5IHJldHVybiB0aGF0IG1hbnkgcm93cywgZXZlbiB3aXRob3V0IGFueSBvZiB0aGUgbG9hZFhZWlxyXG4gICAgICogbWV0aG9kcyBhYm92ZSBiZWluZyBjYWxsZWQuXHJcbiAgICAgKlxyXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyB3aGVuIHRoZSBjb21wb25lbnQgc2l6ZSBpcyBub3Qga25vd24gaW5pdGlhbGx5IGFuZCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgdGhlXHJcbiAgICAgKiBjb21wb25lbnQgd2FudHMgdG8gbG9hZCBkZXBlbmRzIG9uIHRoYXQuIEFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBrbm93cyBob3cgbWFueSBpdCB3YW50c1xyXG4gICAgICogaW5pdGlhbGx5IGl0IGNhbiBjYWxsIHRoaXMgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIFRoZXNlIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBpbml0aWFsbHkgdXNpbmcgdGhlIC5zcGVjIG9wdGlvbnMgXCJpbml0aWFsUHJlZmVycmVkVmlld1BvcnRTaXplXCIgYW5kXHJcbiAgICAgKiBcInNlbmRTZWxlY3Rpb25WaWV3cG9ydEluaXRpYWxseVwiLiBCdXQgdGhlc2UgY2FuIGJlIGFsdGVyZWQgYXQgcnVudGltZSB2aWEgdGhpcyBtZXRob2QgYXMgd2VsbFxyXG4gICAgICogYmVjYXVzZSB0aGV5IGFyZSB1c2VkL3VzZWZ1bCBpbiBvdGhlciBzY2VuYXJpb3MgYXMgd2VsbCwgbm90IGp1c3QgaW5pdGlhbGx5OiBmb3IgZXhhbXBsZSB3aGVuIGFcclxuICAgICAqIHJlbGF0ZWQgZm91bmRzZXQgY2hhbmdlcyBwYXJlbnQgcmVjb3JkLCB3aGVuIGEgc2VhcmNoL2ZpbmQgaXMgcGVyZm9ybWVkIGFuZCBzbyBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJlZmVycmVkU2l6ZSB0aGUgcHJlZmVycmVkIG51bWJlciBvciByb3dzIHRoYXQgdGhlIHZpZXdwb3J0IHNob3VsZCBnZXQgYXV0b21hdGljYWxseVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHNlbmRWaWV3cG9ydFdpdGhTZWxlY3Rpb24gaWYgdGhpcyBpcyB0cnVlLCB0aGUgYXV0by1zZW50IHZpZXdwb3J0IHdpbGwgY29udGFpblxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzZWxlY3RlZCByb3cgKGlmIGFueSkuXHJcbiAgICAgKiBAcGFyYW0gY2VudGVyVmlld3BvcnRPblNlbGVjdGVkIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlIHNlbGVjdGVkIHJvdyB3aWxsIGJlIGluIHRoZSBtaWRkbGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGF1dG8tc2VudCB2aWV3cG9ydCBpZiBwb3NzaWJsZS4gSWYgaXQgaXMgZmFsc2UsIHRoZW5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmb3VuZHNldCBwcm9wZXJ0eSB0eXBlIHdpbGwgYXNzdW1lIGEgJ3BhZ2luZydcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5IGFuZCB3aWxsIHNlbmQgdGhlIHBhZ2UgdGhhdCBjb250YWlucyB0aGVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIHJvdyAoaGVyZSB0aGUgcGFnZSBzaXplIGlzIGFzc3VtZWQgdG8gYmVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZFNpemUpLlxyXG4gICAgICovXHJcbiAgICBzZXRQcmVmZXJyZWRWaWV3cG9ydFNpemUocHJlZmVycmVkU2l6ZTogbnVtYmVyLCBzZW5kVmlld3BvcnRXaXRoU2VsZWN0aW9uPzogYm9vbGVhbiwgY2VudGVyVmlld3BvcnRPblNlbGVjdGVkPzogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNlaXZlcyBhIGNsaWVudCBzaWRlIHJvd0lEICh0YWtlbiBmcm9tIG15Rm91bmRzZXRQcm9wLnZpZXdQb3J0LnJvd3NbaWR4XS5fc3Z5Um93SWQpXHJcbiAgICAgKiBhbmQgZ2l2ZXMgYSBSZWNvcmQgcmVmZXJlbmNlLCBhbiBvYmplY3RcclxuICAgICAqIHdoaWNoIGNhbiBiZSByZXNvbHZlZCBzZXJ2ZXIgc2lkZSB0byB0aGUgZXhhY3QgUmVjb3JkIHZpYSB0aGUgJ3JlY29yZCcgcHJvcGVydHkgdHlwZTtcclxuICAgICAqIGZvciBleGFtcGxlIGlmIHlvdSBjYWxsIGEgaGFuZGxlciBvciBhIHNlcnZveWFwaS5jYWxsU2VydmVyU2lkZUFwaSguLi4pIGFuZCB3YW50XHJcbiAgICAgKiB0byBnaXZlIGl0IGEgUmVjb3JkIGFzIHBhcmFtZXRlciBhbmQgeW91IGhhdmUgdGhlIHJvd0lEIGFuZCBmb3VuZHNldCBpbiB5b3VyIGNvZGUsXHJcbiAgICAgKiB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZC4gRS5nOiBzZXJ2b3lhcGkuY2FsbFNlcnZlclNpZGVBcGkoXCJkb1NvbWV0aGluZ1dpdGhSZWNvcmRcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgW3RoaXMubXlGb3VuZHNldFByb3BlcnR5LmdldFJlY29yZFJlZkJ5Um93SUQoY2xpY2tlZFJvd0lkKV0pO1xyXG4gICAgICpcclxuICAgICAqIE5PVEU6IGlmIGluIHlvdXIgY29tcG9uZW50IHlvdSBrbm93IHRoZSB3aG9sZSByb3cgKHNvIG15Rm91bmRzZXRQcm9wLnZpZXdQb3J0LnJvd3NbaWR4XSlcclxuICAgICAqIGFscmVhZHkgLSBub3QganVzdCB0aGUgcm93SUQgLSB0aGF0IHlvdSB3YW50IHRvIHNlbmQgeW91IGNhbiBqdXN0IGdpdmUgdGhhdCBkaXJlY3RseSB0byB0aGVcclxuICAgICAqIGhhbmRsZXIvc2VydmVyU2lkZUFwaTsgeW91IGRvIG5vdCBuZWVkIHRvIHVzZSB0aGlzIG1ldGhvZCBpbiB0aGF0IGNhc2UuIEUuZzpcclxuICAgICAqIC8vIGlmIHlvdSBoYXZlIHRoZSBpbmRleCBpbnNpZGUgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBzZXJ2b3lhcGkuY2FsbFNlcnZlclNpZGVBcGkoXCJkb1NvbWV0aGluZ1dpdGhSZWNvcmRcIixcclxuICAgICAqICAgICAgICAgICBbdGhpcy5teUZvdW5kc2V0UHJvcGVydHkudmlld1BvcnQucm93c1tjbGlja2VkUm93SWR4XV0pO1xyXG4gICAgICogLy8gb3IgaWYgeW91IGhhdmUgdGhlIHJvdyBkaXJlY3RseVxyXG4gICAgICogc2Vydm95YXBpLmNhbGxTZXJ2ZXJTaWRlQXBpKFwiZG9Tb21ldGhpbmdXaXRoUmVjb3JkXCIsIFtjbGlja2VkUm93XSk7XHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaGFzIGJlZW4gYWRkZWQgaW4gU2Vydm95IDguMy5cclxuICAgICAqL1xyXG4gICAgZ2V0UmVjb3JkUmVmQnlSb3dJRChyb3dJZDogc3RyaW5nKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIgdGhhdCB3aWxsIGdldCB0cmlnZ2VyZWQgd2hlbiBzZXJ2ZXIgc2VuZHMgY2hhbmdlcyBmb3IgdGhpcyBmb3VuZHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIFdlYnNvY2tldFNlc3Npb24uYWRkSW5jb21pbmdNZXNzYWdlSGFuZGxpbmdEb25lVGFzayBpZiB5b3UgbmVlZCB5b3VyIGNvZGUgdG8gZXhlY3V0ZSBhZnRlciBhbGwgcHJvcGVydGllcyB0aGF0IHdlcmUgbGlua2VkIHRvIHRoaXMgZm91bmRzZXRcclxuICAgICAgICAgICAgICAgICBnZXQgdGhlaXIgY2hhbmdlcyBhcHBsaWVkIHlvdSBjYW4gdXNlIFdlYnNvY2tldFNlc3Npb24uYWRkSW5jb21pbmdNZXNzYWdlSGFuZGxpbmdEb25lVGFzay5cclxuICAgICAqIEBwYXJhbSBjaGFuZ2VMaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gcmVnaXN0ZXIuXHJcbiAgICAgKi9cclxuICAgIGFkZENoYW5nZUxpc3RlbmVyKGNoYW5nZUxpc3RlbmVyOiBGb3VuZHNldENoYW5nZUxpc3RlbmVyKTogKCkgPT4gdm9pZDtcclxuICAgIHJlbW92ZUNoYW5nZUxpc3RlbmVyKGNoYW5nZUxpc3RlbmVyOiBGb3VuZHNldENoYW5nZUxpc3RlbmVyKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcmsgdGhlIGZvdW5kc2V0IGRhdGEgYXMgY2hhbmdlZCBvbiB0aGUgY2xpZW50LlxyXG4gICAgICogSWYgcHVzaCB0byBzZXJ2ZXIgaXMgYWxsb3dlZCBmb3IgdGhpcyBmb3VuZHNldCB0aGVuIHRoZSBjaGFuZ2VzIHdpbGwgYmUgc2VudCB0byB0aGUgc2VydmVyLCBvdGh3ZXJ3aXNlIHRoZSBjaGFuZ2VzIGFyZSBpZ25vcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleCBpcyB0aGUgcm93IGluZGV4IChyZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQpIHdoZXJlIHRoZSBkYXRhIGNoYW5nZSBvY2N1cnJlZFxyXG4gICAgICogQHBhcmFtIGNvbHVtbklEIHRoZSBuYW1lIG9mIHRoZSBjb2x1bW5cclxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZSB0aGUgbmV3IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWUgdGhlIG9sZCB2YWx1ZSwgaXMgb3B0aW9uYWw7IHRoZSBjaGFuZ2UgaXMgaWdub3JlZCBpZiB0aGUgb2xkVmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIG5ld1ZhbHVlXHJcbiAgICAgKi9cclxuICAgIGNvbHVtbkRhdGFDaGFuZ2VkKGluZGV4OiBudW1iZXIsIGNvbHVtbklEOiBzdHJpbmcsIG5ld1ZhbHVlOiBhbnksIG9sZFZhbHVlPzogYW55KTogdm9pZDtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlld3BvcnRDaGFuZ2VFdmVudCB7XHJcbiAgICAvLyB0aGUgZm9sbG93aW5nIGtleXMgYXBwZWFyIGlmIGVhY2ggb2YgdGhlc2UgZ290IHVwZGF0ZWQgZnJvbSBzZXJ2ZXI7IHRoZSBuYW1lcyBvZiB0aG9zZVxyXG4gICAgLy8ga2V5cyBzdWdnZXN0IHdoYXQgaXQgd2FzIHRoYXQgY2hhbmdlZDsgb2xkVmFsdWUgYW5kIG5ld1ZhbHVlIGFyZSB0aGUgdmFsdWVzIGZvciB3aGF0IGNoYW5nZWRcclxuICAgIC8vIChlLmcuIG5ldyBzZXJ2ZXIgc2l6ZSBhbmQgb2xkIHNlcnZlciBzaXplKSBzbyBub3QgdGhlIHdob2xlIGZvdW5kc2V0IHByb3BlcnR5IG5ldy9vbGQgdmFsdWVcclxuICAgIHZpZXdwb3J0Um93c0NvbXBsZXRlbHlDaGFuZ2VkPzogeyBvbGRWYWx1ZTogYW55W107IG5ld1ZhbHVlOiBhbnlbXSB9O1xyXG5cclxuICAgIC8vIGlmIHdlIHJlY2VpdmVkIGFkZC9yZW1vdmUvY2hhbmdlIG9wZXJhdGlvbnMgb24gYSBzZXQgb2Ygcm93cyBmcm9tIHRoZSB2aWV3cG9ydCwgdGhpcyBrZXlcclxuICAgIC8vIHdpbGwgYmUgc2V0OyBhcyBzZWVuIGJlbG93LCBpdCBjb250YWlucyBcInVwZGF0ZXNcIiB3aGljaCBpcyBhbiBhcnJheSB0aGF0IGhvbGRzIGEgc2VxdWVuY2Ugb2ZcclxuICAgIC8vIGdyYW51bGFyIHVwZGF0ZSBvcGVyYXRpb25zIHRvIHRoZSB2aWV3cG9ydDsgdGhlIGFycmF5IHdpbGwgaG9sZCBvbmUgb3IgbW9yZSBncmFudWxhciBhZGQgb3IgcmVtb3ZlXHJcbiAgICAvLyBvciB1cGRhdGUgb3BlcmF0aW9ucztcclxuICAgIC8vIGFsbCB0aGUgXCJzdGFydEluZGV4XCIgYW5kIFwiZW5kSW5kZXhcIiB2YWx1ZXMgYmVsb3cgYXJlIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCdzIHN0YXRlIGFmdGVyIGFsbFxyXG4gICAgLy8gcHJldmlvdXMgdXBkYXRlcyBpbiB0aGUgYXJyYXkgd2VyZSBhbHJlYWR5IHByb2Nlc3NlZCAoc28gdGhleSBhcmUgTk9UIHJlbGF0aXZlIHRvIHRoZSBpbml0aWFsIHN0YXRlKTtcclxuICAgIC8vIGluZGV4ZXMgYXJlIDAgYmFzZWRcclxuICAgIHZpZXdwb3J0Um93c1VwZGF0ZWQ/OiBWaWV3cG9ydFJvd1VwZGF0ZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRm91bmRzZXRDaGFuZ2VFdmVudCBleHRlbmRzIFZpZXdwb3J0Q2hhbmdlRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIG5vbi1udWxsLCBoYWQgbGlzdGVuZXJzIGFuZCBhIGZ1bGwgdmFsdWUgdXBkYXRlIHdhc1xyXG4gICAgICogcmVjZWl2ZWQgZnJvbSBzZXJ2ZXIsIHRoaXMga2V5IGlzIHNldCBvbiB0aGUgY2hhbmdlIGV2ZW50OyBpZiBuZXdWYWx1ZSBpcyBub24tbnVsbCwgaXQgd2lsbCBrZWVwIHRoZSBzYW1lIHJlZmVyZW5jZSBhcyBiZWZvcmU7XHJcbiAgICAgKiBpdCB3aWxsIGp1c3QgdXBkYXRlIGl0J3MgY29udGVudHM7IG9sZFZhbHVlIHdpbGwgYmUgYSBkdW1teSBzaGFsbG93IGNvcHkgb2Ygb2xkIHZhbHVlIGNvbnRlbnRzXHJcbiAgICAgKi9cclxuICAgIGZ1bGxWYWx1ZUNoYW5nZWQ/OiB7IG9sZFZhbHVlOiBJRm91bmRzZXRGaWVsZHNPbmx5OyBuZXdWYWx1ZTogSUZvdW5kc2V0IH07XHJcblxyXG4gICAgLy8gdGhlIGZvbGxvd2luZyBrZXlzIGFwcGVhciBpZiBlYWNoIG9mIHRoZXNlIGdvdCB1cGRhdGVkIGZyb20gc2VydmVyOyB0aGUgbmFtZXMgb2YgdGhvc2VcclxuICAgIC8vIGtleXMgc3VnZ2VzdCB3aGF0IGl0IHdhcyB0aGF0IGNoYW5nZWQ7IG9sZFZhbHVlIGFuZCBuZXdWYWx1ZSBhcmUgdGhlIHZhbHVlcyBmb3Igd2hhdCBjaGFuZ2VkXHJcbiAgICAvLyAoZS5nLiBuZXcgc2VydmVyIHNpemUgYW5kIG9sZCBzZXJ2ZXIgc2l6ZSkgc28gbm90IHRoZSB3aG9sZSBmb3VuZHNldCBwcm9wZXJ0eSBuZXcvb2xkIHZhbHVlXHJcbiAgICBzZXJ2ZXJGb3VuZHNldFNpemVDaGFuZ2VkPzogeyBvbGRWYWx1ZTogbnVtYmVyOyBuZXdWYWx1ZTogbnVtYmVyIH07XHJcbiAgICBoYXNNb3JlUm93c0NoYW5nZWQ/OiB7IG9sZFZhbHVlOiBib29sZWFuOyBuZXdWYWx1ZTogYm9vbGVhbiB9O1xyXG4gICAgbXVsdGlTZWxlY3RDaGFuZ2VkPzogeyBvbGRWYWx1ZTogYm9vbGVhbjsgbmV3VmFsdWU6IGJvb2xlYW4gfTtcclxuICAgIGNvbHVtbkZvcm1hdHNDaGFuZ2VkPzogeyBvbGRWYWx1ZTogUmVjb3JkPHN0cmluZywgb2JqZWN0PjsgbmV3VmFsdWU6IFJlY29yZDxzdHJpbmcsIG9iamVjdD4gfTtcclxuICAgIHNvcnRDb2x1bW5zQ2hhbmdlZD86IHsgb2xkVmFsdWU6IHN0cmluZzsgbmV3VmFsdWU6IHN0cmluZyB9O1xyXG4gICAgc2VsZWN0ZWRSb3dJbmRleGVzQ2hhbmdlZD86IHsgb2xkVmFsdWU6IG51bWJlcltdOyBuZXdWYWx1ZTogbnVtYmVyW10gfTtcclxuICAgIHZpZXdQb3J0U3RhcnRJbmRleENoYW5nZWQ/OiB7IG9sZFZhbHVlOiBudW1iZXI7IG5ld1ZhbHVlOiBudW1iZXIgfTtcclxuICAgIHZpZXdQb3J0U2l6ZUNoYW5nZWQ/OiB7IG9sZFZhbHVlOiBudW1iZXI7IG5ld1ZhbHVlOiBudW1iZXIgfTtcclxuICAgIHVzZXJTZXRTZWxlY3Rpb24/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBDaGFuZ2VMaXN0ZW5lciA9IChjaGFuZ2VFdmVudDogVmlld3BvcnRDaGFuZ2VFdmVudCkgPT4gdm9pZDtcclxuZXhwb3J0IHR5cGUgRm91bmRzZXRDaGFuZ2VMaXN0ZW5lciA9IChjaGFuZ2VFdmVudDogRm91bmRzZXRDaGFuZ2VFdmVudCkgPT4gdm9pZDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlld3BvcnRSb3dVcGRhdGUgeyB0eXBlOiBDaGFuZ2VUeXBlOyBzdGFydEluZGV4OiBudW1iZXI7IGVuZEluZGV4OiBudW1iZXIgfVxyXG5leHBvcnQgdHlwZSBWaWV3cG9ydFJvd1VwZGF0ZXMgPSBWaWV3cG9ydFJvd1VwZGF0ZVtdO1xyXG5cclxuZXhwb3J0IGVudW0gQ2hhbmdlVHlwZSAge1xyXG4gICAgUk9XU19DSEFOR0VEID0gMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYW4gSU5TRVJUIGhhcHBlbmVkIGJ1dCB2aWV3cG9ydCBzaXplIHJlbWFpbmVkIHRoZSBzYW1lLCBpdCBpc1xyXG4gICAgICogcG9zc2libGUgdGhhdCBzb21lIG9mIHRoZSByb3dzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGF0IHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBzbGlkZWQgb3V0IG9mIGl0O1xyXG4gICAgICogTk9URTogaW5zZXJ0IHNpZ25pZmllcyBhbiBpbnNlcnQgaW50byB0aGUgY2xpZW50IHZpZXdwb3J0LCBub3QgbmVjZXNzYXJpbHlcclxuICAgICAqIGFuIGluc2VydCBpbiB0aGUgZm91bmRzZXQgaXRzZWxmOyBmb3IgZXhhbXBsZSBjYWxsaW5nIFwibG9hZEV4dHJhUmVjb3Jkc0FzeW5jXCJcclxuICAgICAqIGNhbiByZXN1bHQgaW4gYW4gaW5zZXJ0IG5vdGlmaWNhdGlvbiArIGJpZ2dlciB2aWV3cG9ydCBzaXplIG5vdGlmaWNhdGlvblxyXG4gICAgICovXHJcbiAgICBST1dTX0lOU0VSVEVELFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBhIERFTEVURSBoYXBwZW5lZCBpbnNpZGUgdGhlIHZpZXdwb3J0IGJ1dCB0aGVyZSB3ZXJlIG1vcmUgcm93cyBhdmFpbGFibGUgaW4gdGhlXHJcbiAgICAgKiBmb3VuZHNldCBhZnRlciBjdXJyZW50IHZpZXdwb3J0LCBpdCBpcyBwb3NzaWJsZSB0aGF0IHNvbWUgb2YgdGhvc2Ugcm93c1xyXG4gICAgICogc2xpZGVkIGludG8gdGhlIHZpZXdwb3J0O1xyXG4gICAgICogTk9URTogZGVsZXRlIHNpZ25pZmllcyBhIGRlbGV0ZSBmcm9tIHRoZSBjbGllbnQgdmlld3BvcnQsIG5vdCBuZWNlc3NhcmlseVxyXG4gICAgICogYSBkZWxldGUgaW4gdGhlIGZvdW5kc2V0IGl0c2VsZjsgZm9yIGV4YW1wbGUgY2FsbGluZyBcImxvYWRMZXNzUmVjb3Jkc0FzeW5jXCIgY2FuXHJcbiAgICAgKiByZXN1bHQgaW4gYSBkZWxldGUgbm90aWZpY2F0aW9uICsgc21hbGxlciB2aWV3cG9ydCBzaXplIG5vdGlmaWNhdGlvblxyXG4gICAgICovXHJcbiAgICBST1dTX0RFTEVURURcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2VDdXN0b21PYmplY3QgaW1wbGVtZW50cyBJQ3VzdG9tT2JqZWN0IHtcclxuICAgIHByaXZhdGUgc3RhdGUgPSBuZXcgQmFzZUN1c3RvbU9iamVjdFN0YXRlKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5hbGxDaGFuZ2VkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0U3RhdGVIb2xkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBnaXZlIGJhY2sgdGhlIHByb3BlcnRpZXMgdGhhdCBuZWVkcyB0byBiZSB3YXRjaGVkLlxyXG4gICAgICovXHJcbiAgICBnZXRXYXRjaGVkUHJvcGVydGllcygpOiBBcnJheTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlld1BvcnQge1xyXG4gICAgc3RhcnRJbmRleDogbnVtYmVyO1xyXG4gICAgc2l6ZTogbnVtYmVyO1xyXG4gICAgcm93czogVmlld1BvcnRSb3dbXTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlld1BvcnRSb3cgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgIF9zdnlSb3dJZDogc3RyaW5nO1xyXG4gICAgX2NhY2hlPzogTWFwPHN0cmluZywgYW55PjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENoYW5nZUF3YXJlU3RhdGUge1xyXG5cclxuICAgIHB1YmxpYyBhbGxDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgcHJpdmF0ZSBjaGFuZ2VMaXN0ZW5lcjogKCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgaW5Ob3RpZnkgPSBmYWxzZTtcclxuXHJcbiAgICBtYXJrQWxsQ2hhbmdlZChub3RpZnlMaXN0ZW5lcjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWxsQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKG5vdGlmeUxpc3RlbmVyKSB0aGlzLm5vdGlmeUNoYW5nZUxpc3RlbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzQ2hhbmdlcygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hbGxDaGFuZ2VkIHx8IHRoaXMuaW5Ob3RpZnk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q2hhbmdlTGlzdGVuZXIoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5vdGlmeUNoYW5nZUxpc3RlbmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaW5Ob3RpZnkgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZUxpc3RlbmVyKSB0aGlzLmNoYW5nZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgdGhpcy5pbk5vdGlmeSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2VDdXN0b21PYmplY3RTdGF0ZSBleHRlbmRzIENoYW5nZUF3YXJlU3RhdGUge1xyXG5cclxuICAgIC8vIHByb3ZpZGUgYSBoYXNoIHRoYXQgbGV0cyBhcnJheXMgdGhhdCBjb250YWluIGN1c3RvbSBvYmplY3RzIGtub3cgdGhhdCB0aGUgb2JqZWN0IGhhcyBjaGFuZ2VkIG9yIG5vdFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY291bnRlciA9IDA7XHJcblxyXG4gICAgcHVibGljIGNvbnZlcnNpb25JbmZvID0ge307XHJcbiAgICBwdWJsaWMgaWdub3JlQ2hhbmdlcyA9IGZhbHNlO1xyXG5cclxuXHJcbiAgICBwcml2YXRlIGNoYW5nZSA9IDA7XHJcbiAgICBwcml2YXRlIGhhc2ggPSBCYXNlQ3VzdG9tT2JqZWN0U3RhdGUuY291bnRlcisrO1xyXG5cclxuICAgIHByaXZhdGUgY2hhbmdlZEtleXMgPSBuZXcgU2V0PHN0cmluZyB8IG51bWJlcj4oKTtcclxuXHJcbiAgICBoYXNDaGFuZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5oYXNDaGFuZ2VzKCkgfHwgdGhpcy5nZXRDaGFuZ2VkS2V5cygpLnNpemUgPiAwOyAvLyBsZWF2ZSB0aGlzIGFzIGEgbWV0aG9kIGNhbGwgYXMgc29tZSBzdWJjbGFzc2VzIG1pZ2h0IGNvbXB1dGUgdGhlIGNoYW5nZWRLZXlzIGluc2lkZSBnZXRDaGFuZ2VkS2V5cygpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFByb3BlcnR5QW5kSGFuZGxlQ2hhbmdlcyhfdGhpc0Jhc2VDdXN0b29tT2JqZWN0LCBpbnRlcm5hbFByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gX3RoaXNCYXNlQ3VzdG9vbU9iamVjdFtpbnRlcm5hbFByb3BlcnR5TmFtZV07XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIGNoYW5nZWQsIG1hcmsgaXQgYXMgc3VjaCBhbmQgbm90aWZ5IGlmIG5lZWRlZFxyXG4gICAgICAgIHRoaXMubWFya0lmQ2hhbmdlZChwcm9wZXJ0eU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XHJcblxyXG4gICAgICAgIC8vIHVucmVnaXN0ZXIgYXMgbGlzdGVuZXIgdG8gb2xkIHZhbHVlIGlmIG5lZWRlZFxyXG4gICAgICAgIHRoaXMuc2V0Q2hhbmdlTGlzdGVuZXJUb1N1YlZhbHVlSWZOZWVkZWQob2xkVmFsdWUsIHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgIF90aGlzQmFzZUN1c3Rvb21PYmplY3RbaW50ZXJuYWxQcm9wZXJ0eU5hbWVdID0gdmFsdWU7XHJcblxyXG4gICAgICAgIC8vIHJlZ2lzdGVyIGFzIGxpc3RlbmVyIHRvIG5ldyB2YWx1ZSBpZiBuZWVkZWRcclxuICAgICAgICB0aGlzLnNldENoYW5nZUxpc3RlbmVyVG9TdWJWYWx1ZUlmTmVlZGVkKHZhbHVlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0lmQ2hhbmdlZChwcm9wZXJ0eU5hbWUsIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMgdmFsdWUgaGFzIGNoYW5nZWQgYnkgcmVmZXJlbmNlOyBzbyBpdCBuZWVkcyB0byBiZSBmdWxseSBzZW50IHRvIHNlcnZlciAtIGV4Y2VwdCBmb3Igd2hlbiBpdCBub3cgYXJyaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGlzIGJlaW5nIHNldCAoaW4gd2hpY2ggY2FzZSBpZ25vcmVDaGFuZ2VzIGlzIHRydWUpXHJcbiAgICAgICAgaWYgKCF0aGlzLmlnbm9yZUNoYW5nZXMgJiYgaW5zdGFuY2VPZkNoYW5nZUF3YXJlVmFsdWUodmFsdWUpKSB2YWx1ZS5nZXRTdGF0ZUhvbGRlcigpLm1hcmtBbGxDaGFuZ2VkKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q2hhbmdlZEtleXMoKTogU2V0PHN0cmluZyB8IG51bWJlcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZWRLZXlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhckNoYW5nZXMoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VkS2V5cy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuYWxsQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIYXNoS2V5KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCArICdfJyArIHRoaXMuY2hhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBtYXJrSWZDaGFuZ2VkKHByb3BlcnR5TmFtZTogc3RyaW5nIHwgbnVtYmVyLCBuZXdPYmplY3Q6IGFueSwgb2xkT2JqZWN0OiBhbnkpIHtcclxuICAgICAgICBpZiAodGhpcy50ZXN0Q2hhbmdlZChwcm9wZXJ0eU5hbWUsIG5ld09iamVjdCwgb2xkT2JqZWN0KSkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hDaGFuZ2UocHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldENoYW5nZUxpc3RlbmVyVG9TdWJWYWx1ZUlmTmVlZGVkKHZhbHVlOiBhbnksIGNoYW5nZUxpc3RlbmVyOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlT2ZDaGFuZ2VBd2FyZVZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAvLyBjaGlsZCBpcyBhYmxlIHRvIGhhbmRsZSBpdCdzIG93biBjaGFuZ2UgbWVjaGFuaXNtXHJcbiAgICAgICAgICAgIHZhbHVlLmdldFN0YXRlSG9sZGVyKCkuc2V0Q2hhbmdlTGlzdGVuZXIoY2hhbmdlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHB1c2hDaGFuZ2UocHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQ2hhbmdlcykgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZWRLZXlzLnNpemUgPT09IDApIHRoaXMuY2hhbmdlKys7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jaGFuZ2VkS2V5cy5oYXMocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRLZXlzLmFkZChwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGVzdENoYW5nZWQocHJvcGVydHlOYW1lOiBzdHJpbmcgfCBudW1iZXIsIG5ld09iamVjdDogYW55LCBvbGRPYmplY3Q6IGFueSkge1xyXG4gICAgICAgIGlmIChuZXdPYmplY3QgIT09IG9sZE9iamVjdCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmplY3QgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlT2ZDaGFuZ2VBd2FyZVZhbHVlKG5ld09iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3QuZ2V0U3RhdGVIb2xkZXIoKS5oYXNDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDaGFuZ2VkKG5ld09iamVjdCwgb2xkT2JqZWN0LCB0aGlzLmNvbnZlcnNpb25JbmZvW3Byb3BlcnR5TmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFycmF5U3RhdGUgZXh0ZW5kcyBCYXNlQ3VzdG9tT2JqZWN0U3RhdGUge1xyXG4gICAgcHJpdmF0ZSBkaWZmZXI6IEl0ZXJhYmxlRGlmZmVyPEFycmF5PGFueT4+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYXJyYXk6IEFycmF5PGFueT4sIHByaXZhdGUgaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYWxsQ2hhbmdlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluaXREaWZmZXIoKSB7XHJcbiAgICAgICAgdGhpcy5kaWZmZXIgPSB0aGlzLml0ZXJhYmxlRGlmZmVycy5maW5kKHRoaXMuYXJyYXkpLmNyZWF0ZSgoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZU9mQmFzZUN1c3RvbU9iamVjdChpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2V0U3RhdGVIb2xkZXIoKS5nZXRIYXNoS2V5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kaWZmZXIuZGlmZih0aGlzLmFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYXJDaGFuZ2VzKCkge1xyXG4gICAgICAgIHN1cGVyLmNsZWFyQ2hhbmdlcygpO1xyXG4gICAgICAgIHRoaXMuaW5pdERpZmZlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDaGFuZ2VkS2V5cygpOiBTZXQ8c3RyaW5nIHwgbnVtYmVyPiB7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdXBlci5nZXRDaGFuZ2VkS2V5cygpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5Q2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5hcnJheSk7XHJcbiAgICAgICAgaWYgKGFycmF5Q2hhbmdlcykge1xyXG4gICAgICAgICAgICBsZXQgYWRkZWRPclJlbW92ZWQgPSAwO1xyXG4gICAgICAgICAgICBhcnJheUNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbSgocmVjb3JkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZGRlZE9yUmVtb3ZlZCsrO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5hZGQocmVjb3JkLmN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhcnJheUNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKChyZWNvcmQpID0+IHtcclxuICAgICAgICAgICAgICAgIGFkZGVkT3JSZW1vdmVkLS07XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmFkZChyZWNvcmQucHJldmlvdXNJbmRleCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYXJyYXlDaGFuZ2VzLmZvckVhY2hNb3ZlZEl0ZW0oKHJlY29yZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlT2ZDaGFuZ2VBd2FyZVZhbHVlKHJlY29yZC5pdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQuaXRlbS5nZXRTdGF0ZUhvbGRlcigpLm1hcmtBbGxDaGFuZ2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChhZGRlZE9yUmVtb3ZlZCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2l6ZSBjaGFuZ2VkLCBmb3Igbm93IHNlbmQgd2hvbGUgYXJyYXlcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya0FsbENoYW5nZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlc0FycmF5ID0gQXJyYXkuZnJvbShjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXNBcnJheS5zb3J0KChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSAtIGIpO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IG5ldyBTZXQoY2hhbmdlc0FycmF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uUmVmIHtcclxuICAgIF9zdnlSb3dJZDogc3RyaW5nO1xyXG4gICAgZHA6IHN0cmluZztcclxuICAgIHZhbHVlOiBzdHJpbmc7XHJcbn07XHJcblxyXG4iXX0=