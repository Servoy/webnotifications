import * as i0 from '@angular/core';
import { Directive, Input, ViewChild, Injectable, Inject, HostListener, Pipe, forwardRef, HostBinding, NgModule, ChangeDetectorRef } from '@angular/core';
import { DOCUMENT, getLocaleNumberSymbol, NumberSymbol } from '@angular/common';
import { Subject } from 'rxjs';
import * as i1 from '@angular/platform-browser';
import numbro from 'numbro';
import { DateTime } from 'luxon';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { __decorate, __param, __awaiter } from 'tslib';

// eslint-disable-next-line
class ServoyBaseComponent {
    constructor(renderer, cdRef) {
        this.renderer = renderer;
        this.cdRef = cdRef;
        this.viewStateListeners = new Set();
        this.componentContributor = new ComponentContributor();
    }
    // final method, do not override
    ngOnInit() {
        this.initializeComponent();
        this.servoyApi.registerComponent(this);
    }
    // final method, do not override
    ngAfterViewInit() {
        this.initializeComponent();
        if (this.elementRef && this.changes) {
            this.svyOnChanges(this.changes);
            this.changes = null;
        }
        this.cdRef.detectChanges();
    }
    // final method, do not override
    ngOnChanges(changes) {
        this.initializeComponent();
        if (!this.elementRef) {
            if (this.changes == null) {
                this.changes = changes;
            }
            else {
                for (const property of Object.keys(changes)) {
                    this.changes[property] = changes[property];
                }
            }
        }
        else {
            if (this.changes == null) {
                this.svyOnChanges(changes);
            }
            else {
                for (const property of Object.keys(changes)) {
                    this.changes[property] = changes[property];
                }
                this.svyOnChanges(this.changes);
                this.changes = null;
            }
        }
    }
    ngOnDestroy() {
        this.servoyApi.unRegisterComponent(this);
    }
    // our init event that is called when dom is ready
    svyOnInit() {
        this.addAttributes();
        this.componentContributor.componentCreated(this);
        this.viewStateListeners.forEach(listener => listener.afterViewInit());
    }
    // our change event that is called when dom is ready
    svyOnChanges(_changes) {
    }
    detectChanges() {
        this.cdRef.detectChanges();
    }
    /**
     * this should return the main native element (like the first div)
     */
    getNativeElement() {
        return this.elementRef ? this.elementRef.nativeElement : null;
    }
    /**
     * sub classes can return a different native child then the default main element.
     * used currently only for horizontal aligment
     */
    getNativeChild() {
        return this.elementRef.nativeElement;
    }
    getRenderer() {
        return this.renderer;
    }
    getWidth() {
        return this.getNativeElement().parentNode.parentNode.offsetWidth;
    }
    getHeight() {
        return this.getNativeElement().parentNode.parentNode.offsetHeight;
    }
    getLocationX() {
        return this.getNativeElement().parentNode.parentNode.offsetLeft;
    }
    getLocationY() {
        return this.getNativeElement().parentNode.parentNode.offsetTop;
    }
    addViewStateListener(listener) {
        this.viewStateListeners.add(listener);
    }
    removeViewStateListener(listener) {
        this.viewStateListeners.delete(listener);
    }
    initializeComponent() {
        if (!this.initialized && this.elementRef) {
            this.initialized = true;
            this.svyOnInit();
        }
    }
    addAttributes() {
        if (!this.servoyAttributes)
            return;
        for (const key of Object.keys(this.servoyAttributes)) {
            this.renderer.setAttribute(this.getNativeElement(), key, this.servoyAttributes[key]);
        }
    }
}
ServoyBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyBaseComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
ServoyBaseComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: ServoyBaseComponent, inputs: { name: "name", servoyApi: "servoyApi", servoyAttributes: "servoyAttributes" }, viewQueries: [{ propertyName: "elementRef", first: true, predicate: ["element"], descendants: true }], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyBaseComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { name: [{
                type: Input
            }], servoyApi: [{
                type: Input
            }], servoyAttributes: [{
                type: Input
            }], elementRef: [{
                type: ViewChild,
                args: ['element', { static: false }]
            }] } });
class ComponentContributor {
    componentCreated(component) {
        ComponentContributor.listeners.forEach(listener => listener.componentCreated(component));
    }
    addComponentListener(listener) {
        ComponentContributor.listeners.add(listener);
    }
}
ComponentContributor.listeners = new Set();
ComponentContributor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ComponentContributor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ComponentContributor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ComponentContributor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ComponentContributor, decorators: [{
            type: Injectable
        }] });

class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this._reject = reject;
            this._resolve = resolve;
        });
    }
    reject(reason) {
        this._reject(reason);
    }
    resolve(value) {
        this._resolve(value);
    }
}

class JSEvent {
}

function getWindow() {
    return window;
}
class WindowRefService {
    get nativeWindow() {
        return getWindow();
    }
}
WindowRefService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: WindowRefService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
WindowRefService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: WindowRefService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: WindowRefService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

// log levels for when debugEnabled(true) is called - if that is false, these levels are irrelevant
// any custom debug levels can be used as well - these are just stored here so that custom code can test the level and see if it should log its message
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
    LogLevel[LogLevel["SPAM"] = 5] = "SPAM";
})(LogLevel || (LogLevel = {}));
class LogConfiguration {
    constructor(isDebugMode = false, level = LogLevel.WARN) {
        this.isDebugMode = isDebugMode;
        this.level = level;
    }
}
const noop = () => undefined;
class LoggerService {
    constructor(windowRefService, svyLogConfiguration, className) {
        this.svyLogConfiguration = svyLogConfiguration;
        this.className = className;
        this.enabled = false;
        this.console = windowRefService.nativeWindow.console;
    }
    buildMessage(message) {
        if (this.enabled) {
            return message instanceof Function ? message() : message;
        }
    }
    get spam() {
        if (this.svyLogConfiguration.level >= LogLevel.SPAM) {
            this.enabled = true;
            return this.console.debug.bind(this.console, this.getTime() + ' SPAM ' + this.className + ' - ');
        }
        this.enabled = false;
        return noop;
    }
    get debug() {
        if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= LogLevel.DEBUG) {
            this.enabled = true;
            return this.console.debug.bind(this.console, this.getTime() + ' DEBUG ' + this.className + ' - ');
        }
        this.enabled = false;
        return noop;
    }
    get info() {
        if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= LogLevel.INFO) {
            this.enabled = true;
            return this.console.info.bind(this.console, this.getTime() + ' INFO ' + this.className + ' - ');
        }
        this.enabled = false;
        return noop;
    }
    get warn() {
        if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= LogLevel.WARN) {
            this.enabled = true;
            return this.console.warn.bind(this.console, this.getTime() + ' WARN ' + this.className + ' - ');
        }
        this.enabled = false;
        return noop;
    }
    get error() {
        if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= LogLevel.ERROR) {
            this.enabled = true;
            return this.console.error.bind(this.console, this.getTime() + ' ERROR ' + this.className + ' - ');
        }
        this.enabled = false;
        return noop;
    }
    toggleDebugMode() {
        return this.svyLogConfiguration.isDebugMode = !this.svyLogConfiguration.isDebugMode;
    }
    get logLevel() {
        return this.svyLogConfiguration.level;
    }
    set logLevel(level) {
        this.svyLogConfiguration.level = level;
    }
    getTime() {
        const time = new Date();
        return time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds();
    }
}
class LoggerFactory {
    constructor(windowRefService) {
        this.windowRefService = windowRefService;
        this.instances = {};
        windowRefService.nativeWindow.logFactory = this;
        this.defaultLogConfiguration = windowRefService.nativeWindow.svyLogConfiguration;
        if (this.defaultLogConfiguration == null) {
            this.defaultLogConfiguration = new LogConfiguration();
            windowRefService.nativeWindow.svyLogConfiguration = this.defaultLogConfiguration;
            windowRefService.nativeWindow.logLevels = { error: LogLevel.ERROR, debug: LogLevel.DEBUG, info: LogLevel.INFO, warn: LogLevel.WARN, spam: LogLevel.SPAM };
        }
    }
    getLogger(cls) {
        if (this.instances[cls] === undefined) {
            this.instances[cls] = new LoggerService(this.windowRefService, new LogConfiguration(this.defaultLogConfiguration.isDebugMode, this.defaultLogConfiguration.level), cls);
        }
        return this.instances[cls];
    }
}
LoggerFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: LoggerFactory, deps: [{ token: WindowRefService }], target: i0.ɵɵFactoryTarget.Injectable });
LoggerFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: LoggerFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: LoggerFactory, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: WindowRefService }]; } });

class ServoyApi {
}

class TooltipService {
    constructor(_doc, windowRefService) {
        this.windowRefService = windowRefService;
        this.tipmousemove = (e) => {
            if (e.pageX || e.pageY) {
                this.tipmousemouveEventIsPage = true;
                this.tipmousemouveEventX = e.pageX;
                this.tipmousemouveEventY = e.pageY;
            }
            else if (e.clientX || e.clientY) {
                this.tipmousemouveEventIsPage = false;
                this.tipmousemouveEventX = e.clientX;
                this.tipmousemouveEventY = e.clientY;
            }
        };
        this.isTooltipActive = new Subject();
        this.doc = _doc;
    }
    showTooltip(event, message, initialDelay, dismissDelay) {
        let e = event;
        if (!e)
            e = this.windowRefService.nativeWindow.event;
        let targ;
        if (e.target)
            targ = e.target;
        else if (e.srcElement)
            targ = e.srcElement;
        if (targ.nodeType === 3) // defeat Safari bug
            targ = targ.parentNode;
        if (targ.tagName && targ.tagName.toLowerCase() === 'option') { // stop tooltip if over option element
            this.hideTooltip();
            return;
        }
        const tDiv = this.getTooltipDiv();
        tDiv.innerHTML = message;
        tDiv.style.zIndex = '1600';
        tDiv.style.width = '';
        tDiv.style.overflow = 'hidden';
        this.tipmousemove(e);
        if (this.doc.addEventListener) {
            this.doc.addEventListener('mousemove', this.tipmousemove, false);
        }
        this.tipInitialTimeout = setTimeout(() => this.adjustAndShowTooltip(dismissDelay), initialDelay);
    }
    hideTooltip() {
        this.internalHideTooltip();
    }
    getTooltipDiv() {
        if (!this.tooltipDiv) {
            this.tooltipDiv = this.doc.createElement('div');
            this.tooltipDiv.id = 'mktipmsg';
            this.tooltipDiv.className = 'mktipmsg tooltip-inner'; // tooltip-inner class is also used by ui-bootstrap-tpls-0.10.0
            this.doc.getElementsByTagName('body')[0].appendChild(this.tooltipDiv);
        }
        return this.tooltipDiv;
    }
    adjustAndShowTooltip(dismissDelay) {
        let x = 0;
        let y = 0;
        if (this.tipmousemouveEventX || this.tipmousemouveEventY) {
            if (this.tipmousemouveEventIsPage) {
                x = this.tipmousemouveEventX;
                y = this.tipmousemouveEventY;
            }
            else {
                x = this.tipmousemouveEventX + this.doc.body.scrollLeft + this.doc.documentElement.scrollLeft;
                y = this.tipmousemouveEventY + this.doc.body.scrollTop + this.doc.documentElement.scrollTop;
            }
        }
        let wWidth = 0;
        let wHeight = 0;
        if (typeof (this.windowRefService.nativeWindow.innerWidth) == 'number') {
            //Non-IE
            wWidth = this.windowRefService.nativeWindow.innerWidth;
            wHeight = this.windowRefService.nativeWindow.innerHeight;
        }
        else if (this.doc.documentElement && (this.doc.documentElement.clientWidth || this.doc.documentElement.clientHeight)) {
            //IE 6+ in 'standards compliant mode'
            wWidth = this.doc.documentElement.clientWidth;
            wHeight = this.doc.documentElement.clientHeight;
        }
        const tDiv = this.getTooltipDiv();
        tDiv.style.left = x + 10 + 'px';
        tDiv.style.top = y + 10 + 'px';
        tDiv.style.display = 'block';
        const tooltipOffsetWidth = x + 10 + tDiv.offsetWidth;
        if (wWidth < tooltipOffsetWidth) {
            let newLeft = x - 10 - tDiv.offsetWidth;
            if (newLeft < 0) {
                newLeft = 0;
                tDiv.style.width = x - 10 + 'px';
            }
            if (newLeft === 0)
                newLeft = tDiv.offsetWidth;
            tDiv.style.left = newLeft + 'px';
        }
        const tooltipOffsetHeight = y + 10 + tDiv.offsetHeight;
        if (wHeight < tooltipOffsetHeight) {
            const newTop = y - 10 - tDiv.offsetHeight;
            tDiv.style.top = newTop + 'px';
        }
        this.isTooltipActive.next(true);
        this.tipTimeout = setTimeout(() => this.hideTooltip(), dismissDelay);
    }
    internalHideTooltip() {
        if (this.doc.removeEventListener)
            this.doc.removeEventListener('mousemove', this.tipmousemove, false);
        clearTimeout(this.tipInitialTimeout);
        clearTimeout(this.tipTimeout);
        const tDiv = this.getTooltipDiv();
        tDiv.style.display = 'none';
        this.isTooltipActive.next(false);
    }
}
TooltipService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TooltipService, deps: [{ token: DOCUMENT }, { token: WindowRefService }], target: i0.ɵɵFactoryTarget.Injectable });
TooltipService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TooltipService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TooltipService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: WindowRefService }]; } });

class TooltipDirective {
    constructor(tooltipService) {
        this.tooltipService = tooltipService;
        this.isActive = false;
        this.tooltipService.isTooltipActive.subscribe(a => {
            this.isActive = a;
        });
    }
    onMouseEnter(event) {
        if (this.tooltipText)
            this.tooltipService.showTooltip(event, this.tooltipText, 750, 5000);
    }
    onMouseLeave() {
        this.tooltipService.hideTooltip();
    }
    onClick() {
        this.tooltipService.hideTooltip();
    }
    onContextMenu() {
        this.tooltipService.hideTooltip();
    }
    ngOnDestroy() {
        this.tooltipService.hideTooltip();
    }
}
TooltipDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TooltipDirective, deps: [{ token: TooltipService }], target: i0.ɵɵFactoryTarget.Directive });
TooltipDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: TooltipDirective, selector: "[svyTooltip]", inputs: { tooltipText: ["svyTooltip", "tooltipText"] }, host: { listeners: { "mouseenter": "onMouseEnter()", "mouseleave": "onMouseLeave()", "click": "onClick()", "contextmenu": "onContextMenu()" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TooltipDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[svyTooltip]' }]
        }], ctorParameters: function () { return [{ type: TooltipService }]; }, propDecorators: { tooltipText: [{
                type: Input,
                args: ['svyTooltip']
            }], onMouseEnter: [{
                type: HostListener,
                args: ['mouseenter']
            }], onMouseLeave: [{
                type: HostListener,
                args: ['mouseleave']
            }], onClick: [{
                type: HostListener,
                args: ['click']
            }], onContextMenu: [{
                type: HostListener,
                args: ['contextmenu']
            }] } });

class ServoyPublicService {
}
ServoyPublicService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ServoyPublicService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicService, decorators: [{
            type: Injectable
        }] });

class DecimalkeyconverterDirective {
    constructor(el, servoyService) {
        this.el = el;
        this.servoyService = servoyService;
        this.element = el.nativeElement;
    }
    onKeypress(e) {
        if (e.which === 110 && this.svyFormat && this.svyFormat.type === 'NUMBER') {
            const caretPos = this.element.selectionStart;
            const startString = this.element.value.slice(0, caretPos);
            const endString = this.element.value.slice(this.element.selectionEnd, this.element.value.length);
            this.element.value = (startString + getLocaleNumberSymbol(this.servoyService.getLocale(), NumberSymbol.Decimal) + endString);
            this.element.focus();
            this.element.setSelectionRange(caretPos + 1, caretPos + 1);
            if (e.preventDefault)
                e.preventDefault();
        }
    }
}
DecimalkeyconverterDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: DecimalkeyconverterDirective, deps: [{ token: i0.ElementRef }, { token: ServoyPublicService }], target: i0.ɵɵFactoryTarget.Directive });
DecimalkeyconverterDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: DecimalkeyconverterDirective, selector: "[svyDecimalKeyConverter]", inputs: { svyFormat: ["svyDecimalKeyConverter", "svyFormat"] }, host: { listeners: { "keydown": "onKeypress($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: DecimalkeyconverterDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[svyDecimalKeyConverter]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ServoyPublicService }]; }, propDecorators: { svyFormat: [{
                type: Input,
                args: ['svyDecimalKeyConverter']
            }], onKeypress: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

class MnemonicletterFilterPipe {
    transform(input, letter) {
        if (letter && input)
            return input.replace(letter, '<u>' + letter + '</u>');
        return input;
    }
}
MnemonicletterFilterPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: MnemonicletterFilterPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
MnemonicletterFilterPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: MnemonicletterFilterPipe, name: "mnemonicletterFilter" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: MnemonicletterFilterPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'mnemonicletterFilter' }]
        }] });
class NotNullOrEmptyPipe {
    transform(value, _args) {
        if (value)
            return value.filter(a => a && (a.realValue || a.displayValue));
        return value;
    }
}
NotNullOrEmptyPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NotNullOrEmptyPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NotNullOrEmptyPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NotNullOrEmptyPipe, name: "notNullOrEmpty" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NotNullOrEmptyPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'notNullOrEmpty' }]
        }] });
class HtmlFilterPipe {
    transform(input) {
        if (input && input.indexOf && input.indexOf('<body') >= 0 && input.lastIndexOf('</body') >= 0) {
            input = input.substring(input.indexOf('<body') + 6, input.lastIndexOf('</body'));
        }
        return input;
    }
}
HtmlFilterPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: HtmlFilterPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
HtmlFilterPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: HtmlFilterPipe, name: "htmlFilter" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: HtmlFilterPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'htmlFilter' }]
        }] });
class TrustAsHtmlPipe {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    transform(input, trustAsHtml) {
        if (trustAsHtml) {
            return this.domSanitizer.bypassSecurityTrustHtml(input);
        }
        return input;
    }
}
TrustAsHtmlPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TrustAsHtmlPipe, deps: [{ token: i1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe });
TrustAsHtmlPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TrustAsHtmlPipe, name: "trustAsHtml" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: TrustAsHtmlPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'trustAsHtml' }]
        }], ctorParameters: function () { return [{ type: i1.DomSanitizer }]; } });

const MILLSIGN = '\u2030';
class Format {
    constructor() {
        this.display = null;
        this.uppercase = false;
        this.lowercase = false;
        this.type = null;
        this.isMask = false;
        this.isRaw = false;
        this.isNumberValidator = false;
        this.edit = null;
        this.placeHolder = '';
        this.percent = '';
        this.allowedCharacters = '';
        this.maxLength = 0;
    }
}
class FormattingService {
    constructor(servoyService) {
        this.servoyService = servoyService;
    }
    // formatting stufff
    format(data, format, useEditFormat) {
        const formatString = useEditFormat ? format.edit : format.display;
        if ((!format) || (!format.type) || ((typeof data === 'number') && isNaN(data))) {
            if (!format && ((format.type === 'NUMBER') || (format.type === 'INTEGER')) && (typeof data === 'number') && !isNaN(data)) {
                // make sure is always returned with correct type, otherwise compare will not work well
                return data.toString();
            }
            return data;
        }
        if (data === undefined || data === null)
            return '';
        if ((format.type === 'NUMBER') || (format.type === 'INTEGER')) {
            return this.formatNumbers(data, formatString);
        }
        else if (format.type === 'TEXT') {
            let formattedValue = this.formatText(data, formatString);
            if (format.uppercase)
                formattedValue = formattedValue.toUpperCase();
            else if (format.lowercase)
                formattedValue = formattedValue.toLowerCase();
            return formattedValue;
        }
        else if (format.type === 'DATETIME') {
            return this.formatDate(data, formatString);
        }
        return data;
    }
    testKeyPressed(event, keyCode) {
        let code;
        if (!event)
            event = window.event;
        if (!event)
            return false;
        if (event.keyCode)
            code = event.keyCode;
        else if (event.which)
            code = event.which;
        return code === keyCode;
    }
    // test numbers only
    testForNumbersOnly(e, keyChar, vElement, vFindMode, vCheckNumbers, vSvyFormat, skipMaxLength) {
        if (!vFindMode && vCheckNumbers) {
            if (this.testKeyPressed(e, 13) && e.target.tagName.toUpperCase() === 'INPUT') {
                //do not looses focus, just apply the format and push value
                vElement.dispatchEvent(new CustomEvent('change', { bubbles: true, detail: { text: () => vElement.value } }));
            }
            else if (vSvyFormat.type === 'INTEGER') {
                const currentLanguageNumeralSymbols = numbro.languageData();
                if (keyChar === undefined || keyChar === null) {
                    return this.numbersonly(e, false, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency
                        .symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                }
                else {
                    return this.numbersonlyForChar(keyChar, false, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency.symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                }
            }
            else if (vSvyFormat.type === 'NUMBER' || ((vSvyFormat.type === 'TEXT') && vSvyFormat.isNumberValidator)) {
                const currentLanguageNumeralSymbols = numbro.languageData();
                if (keyChar === undefined || keyChar === null) {
                    return this.numbersonly(e, true, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency.symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                }
                else {
                    return this.numbersonlyForChar(keyChar, true, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency.symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                }
            }
        }
        return true;
    }
    // unformatting stuff
    unformat(data, servoyFormat, type, currentValue) {
        if ((!servoyFormat) || (!type) || (!data && data !== 0))
            return data;
        if ((type === 'NUMBER') || (type === 'INTEGER')) {
            return this.unformatNumbers(data, servoyFormat);
        }
        else if (type === 'TEXT') {
            return data;
        }
        else if (type === 'DATETIME') {
            if ('' === data)
                return null;
            servoyFormat = this.convertFormat(servoyFormat);
            const d = DateTime.fromFormat(data, servoyFormat, { locale: this.servoyService.getLocale() }).toJSDate();
            // if format has not year/month/day use the one from the current model value
            // because luxon will just use current date
            if (currentValue && !isNaN(currentValue.getTime())) {
                if (servoyFormat.indexOf('y') === -1) {
                    d.setFullYear(currentValue.getFullYear());
                }
                if (servoyFormat.indexOf('W') === -1 && servoyFormat.indexOf('o') === -1) {
                    if (servoyFormat.indexOf('M') === -1) {
                        d.setMonth(currentValue.getMonth());
                    }
                    if (servoyFormat.indexOf('d') === -1) {
                        d.setDate(currentValue.getDate());
                    }
                }
            }
            return d;
        }
        return data;
    }
    unformatNumbers(data, format) {
        if (data === '')
            return data;
        //treat scientiffic numbers
        if (data.toString().toLowerCase().indexOf('e') > -1 && !isNaN(data)) {
            return new Number(data).valueOf();
        }
        let multFactor = 1;
        const MILLSIGN = '\u2030';
        if (format.indexOf(MILLSIGN) > -1 && format.indexOf('\'' + MILLSIGN + '\'') == -1) {
            multFactor *= 0.001;
        }
        if (format.indexOf('\'') > -1) {
            // replace the literals
            const parts = format.split('\'');
            for (let i = 0; i < parts.length; i++) {
                if (i % 2 === 1) {
                    data = data.replace(new RegExp(parts[i], 'g'), '');
                }
            }
        }
        let ret = numbro(data).value();
        ret *= multFactor;
        return ret;
    }
    numbersonly(e, decimal, decimalChar, groupingChar, currencyChar, percentChar, vElement, mlength) {
        let key;
        if (window.event) {
            key = window.event['keyCode'];
        }
        else if (e) {
            key = e.which;
        }
        else {
            return true;
        }
        if ((key == null) || (key === 0) || (key === 8) || (key === 9) || (key === 13) || (key === 27) || (e.ctrlKey && key === 97) || (e.ctrlKey && key === 99) ||
            (e.ctrlKey && key === 118) || (e.ctrlKey && key === 120)) { //added CTRL-A, X, C and V
            return true;
        }
        const keychar = String.fromCharCode(key);
        return this.numbersonlyForChar(keychar, decimal, decimalChar, groupingChar, currencyChar, percentChar, vElement, mlength);
    }
    numbersonlyForChar(keychar, decimal, decimalChar, groupingChar, currencyChar, percentChar, vElement, mlength) {
        const value = vElement.value;
        if (mlength > 0 && value) {
            let counter = 0;
            if (('0123456789').indexOf(keychar) !== -1)
                counter++;
            const stringLength = value.length;
            for (let i = 0; i < stringLength; i++) {
                if (('0123456789').indexOf(value.charAt(i)) !== -1)
                    counter++;
            }
            const selectedTxt = this.getSelectedText(vElement);
            if (selectedTxt) {
                // selection will get deleted/replaced by typed key
                for (let i = 0; i < selectedTxt.length; i++) {
                    if (('0123456789').indexOf(selectedTxt.charAt(i)) !== -1)
                        counter--;
                }
            }
            if (counter > mlength)
                return false;
        }
        if ((('-0123456789').indexOf(keychar) > -1)) {
            return true;
        }
        else if (decimal && (keychar === decimalChar)) {
            return true;
        }
        else if (keychar === groupingChar) {
            return true;
        }
        else if (keychar === currencyChar) {
            return true;
        }
        else if (keychar === percentChar) {
            return true;
        }
        return false;
    }
    getSelectedText(textarea) {
        let sel = null;
        if (textarea) {
            const start = textarea['selectionStart'];
            const end = textarea['selectionEnd'];
            sel = textarea['value'].substring(start, end);
        }
        return sel;
    }
    formatNumbers(data, servoyFormat) {
        if (!servoyFormat)
            return data;
        if (data === '')
            return data;
        data = Number(data); // just to make sure that if it was a string representing a number we turn it into a number
        if (typeof data === 'number' && isNaN(data))
            return ''; // cannot format something that is not a number
        const initialData = data;
        let patchedFormat = servoyFormat; // patched format for numeraljs format
        let i;
        let j;
        let prefix = '';
        let sufix = '';
        if (patchedFormat.indexOf(';') > 0) {
            if (data < 0) {
                patchedFormat = patchedFormat.split(';')[1];
            }
            else
                patchedFormat = patchedFormat.split(';')[0];
        }
        if (data < 0)
            data *= -1;
        if (patchedFormat.indexOf('\u00A4') >= 0) {
            patchedFormat = patchedFormat.replace(new RegExp('\u00A4', 'g'), numbro.languageData().currency.symbol);
        }
        if (servoyFormat.indexOf('-') >= 0 && initialData >= 0 && servoyFormat.indexOf(';') < 0) {
            patchedFormat = patchedFormat.replace(new RegExp('-', 'g'), '');
        }
        if (patchedFormat.indexOf('%') > -1 && patchedFormat.indexOf('\'%\'') === -1) {
            data *= 100;
        }
        else if (patchedFormat.indexOf(MILLSIGN) > -1 && patchedFormat.indexOf('\'' + MILLSIGN + '\'') === -1) {
            data *= 1000;
        }
        let numberStart = patchedFormat.length;
        let index = patchedFormat.indexOf('0');
        if (index >= 0) {
            numberStart = index;
        }
        index = patchedFormat.indexOf('#');
        if (index >= 0 && index < numberStart) {
            numberStart = index;
        }
        let numberEnd = 0;
        index = patchedFormat.lastIndexOf('0');
        if (index >= 0) {
            numberEnd = index;
        }
        index = patchedFormat.lastIndexOf('#');
        if (index >= 0 && index > numberEnd) {
            numberEnd = index;
        }
        if (numberStart > 0) {
            prefix = patchedFormat.substring(0, numberStart);
        }
        if (numberEnd < patchedFormat.length - 1) {
            sufix = patchedFormat.substring(numberEnd + 1);
        }
        patchedFormat = patchedFormat.substring(numberStart, numberEnd + 1);
        let ret;
        prefix = prefix.replace(new RegExp('\'', 'g'), '');
        sufix = sufix.replace(new RegExp('\'', 'g'), '');
        if (servoyFormat.indexOf('-') === -1 && initialData < 0 && servoyFormat.indexOf(';') < 0) {
            prefix = prefix + '-';
        }
        // scientific notation case
        if (servoyFormat.indexOf('E') > -1) {
            const frmt = /([0#.,]+)+E0+.*/.exec(patchedFormat)[1];
            let integerDigits = 0;
            let fractionalDigits = 0;
            let countIntegerState = true;
            for (i = 0; i < frmt.length; i++) {
                const chr = frmt[i];
                if (chr === '.') {
                    countIntegerState = false;
                    continue;
                }
                if (chr === ',')
                    continue;
                if (countIntegerState) {
                    integerDigits++;
                }
                else {
                    fractionalDigits++;
                }
            }
            ret = Number(data).toExponential(integerDigits + fractionalDigits);
        }
        else {
            // get min digits
            let minLen = 0;
            let optionalDigits = 0;
            for (i = 0; i < patchedFormat.length; i++) {
                if (patchedFormat[i] === '0') {
                    minLen++;
                }
                else if (patchedFormat[i] === '#' && minLen === 0) {
                    optionalDigits++;
                }
                else if (patchedFormat[i] === '.') {
                    break;
                }
            }
            patchedFormat = patchedFormat.replace(new RegExp('(#+)', 'g'), '[$1]');
            patchedFormat = patchedFormat.replace(new RegExp('#', 'g'), '0');
            ret = numbro(data).format(patchedFormat);
            // set min digits
            if (minLen > 0) {
                const retSplit = ret.split(numbro.languageData().delimiters.decimal);
                for (i = 0; i < retSplit[0].length; i++) {
                    if (retSplit[0][i] < '0' || retSplit[0][i] > '9')
                        continue;
                    for (j = i; j < retSplit[0].length; j++) {
                        if (retSplit[0][j] >= '0' && retSplit[0][j] <= '9')
                            continue;
                        break;
                    }
                    const nrMissing0 = minLen - (j - i);
                    if (nrMissing0 > 0) {
                        ret = retSplit[0].substring(0, i);
                        for (j = 0; j < nrMissing0; j++)
                            ret += '0';
                        ret += retSplit[0].substring(i);
                        if (retSplit.length > 1)
                            ret += (numbro.languageData().delimiters.decimal + retSplit[1]);
                    }
                    break;
                }
            }
            // fix the optional digits
            if (patchedFormat.indexOf(',') === -1 && optionalDigits > 0) {
                let toEliminate = 0;
                for (i = 0; i < ret.length; i++) {
                    if (ret.charAt(i) === '0') {
                        toEliminate++;
                    }
                    else {
                        break;
                    }
                }
                if (toEliminate > 0) {
                    if (toEliminate > optionalDigits) {
                        toEliminate = optionalDigits;
                    }
                    ret = ret.substring(toEliminate);
                    if (ret.indexOf(numbro.languageData().delimiters.decimal) === 0) {
                        // we eliminated too much
                        ret = '0' + ret;
                    }
                }
            }
        }
        return prefix + ret + sufix;
    }
    formatText(data, servoyFormat) {
        if (!servoyFormat)
            return data;
        const error = 'input string not corresponding to format : ' + data + ' , ' + servoyFormat;
        let ret = '';
        let isEscaping = false;
        let offset = 0;
        if (data && typeof data === 'number') {
            data = data.toString();
        }
        for (let i = 0; i < servoyFormat.length; i++) {
            const formatChar = servoyFormat[i];
            const dataChar = data[i - offset];
            if (dataChar === undefined)
                break;
            if (isEscaping && formatChar !== '\'') {
                if (dataChar !== formatChar)
                    throw error;
                ret += dataChar;
                continue;
            }
            switch (formatChar) {
                case '\'':
                    isEscaping = !isEscaping;
                    offset++;
                    break;
                case 'U':
                    if (dataChar.match(/[a-zA-Z\u00C0-\u00ff]/) == null)
                        throw error;
                    ret += dataChar.toUpperCase();
                    break;
                case 'L':
                    if (dataChar.match(/[a-zA-Z\u00C0-\u00ff]/) == null)
                        throw error;
                    ret += dataChar.toLowerCase();
                    break;
                case 'A':
                    if (dataChar.match(/[0-9a-zA-Z\u00C0-\u00ff]/) == null)
                        throw error;
                    ret += dataChar;
                    break;
                case '?':
                    if (dataChar.match(/[a-zA-Z\u00C0-\u00ff]/) == null)
                        throw error;
                    ret += dataChar;
                    break;
                case '*':
                    ret += dataChar;
                    break;
                case 'H':
                    if (dataChar.match(/[0-9a-fA-F]/) == null)
                        throw error;
                    ret += dataChar.toUpperCase();
                    break;
                case '#':
                    if (dataChar.match(/[\d]/) == null)
                        throw error;
                    ret += dataChar;
                    break;
                default:
                    ret += formatChar;
                    if (formatChar !== dataChar)
                        offset++;
                    break;
            }
        }
        return ret;
    }
    formatDate(data, dateFormat) {
        if (!(data instanceof Date))
            return data;
        dateFormat = this.convertFormat(dateFormat);
        const formatted = DateTime.fromJSDate(data).setLocale(this.servoyService.getLocale()).toFormat(dateFormat);
        return formatted.trim ? formatted.trim() : formatted;
    }
    convertFormat(dateFormat) {
        if (!dateFormat)
            dateFormat = 'F'; // long date format of luxon
        // adjust to luxon js formatting (from java simple date format)
        dateFormat = dateFormat.replace(new RegExp('Y', 'g'), 'y');
        dateFormat = dateFormat.replace(new RegExp('aa', 'g'), 'a');
        dateFormat = dateFormat.replace(new RegExp('E', 'g'), 'EEE');
        dateFormat = dateFormat.replace(new RegExp('u', 'g'), 'E');
        dateFormat = dateFormat.replace(new RegExp('w', 'g'), 'W');
        // no equivalent for K, just put h for now
        dateFormat = dateFormat.replace(new RegExp('K', 'g'), 'h');
        dateFormat = dateFormat.replace(new RegExp('k', 'g'), 'H');
        dateFormat = dateFormat.replace(new RegExp('D', 'g'), 'o');
        // if week is found then the year must be 'k' for luxon (iso week year)
        if (dateFormat.indexOf('W') !== -1) {
            dateFormat = dateFormat.replace(new RegExp('y', 'g'), 'k');
        }
        return dateFormat;
    }
}
FormattingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormattingService, deps: [{ token: ServoyPublicService }], target: i0.ɵɵFactoryTarget.Injectable });
FormattingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormattingService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormattingService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: ServoyPublicService }]; } });

class FormatFilterPipe {
    constructor(formatService) {
        this.formatService = formatService;
    }
    transform(input, format) {
        if (!format)
            return input;
        return this.formatService.format(input, format, !format.display);
    }
}
FormatFilterPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormatFilterPipe, deps: [{ token: FormattingService }], target: i0.ɵɵFactoryTarget.Pipe });
FormatFilterPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormatFilterPipe, name: "formatFilter" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormatFilterPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'formatFilter' }]
        }], ctorParameters: function () { return [{ type: FormattingService }]; } });

class EmptyValueFilterPipe {
    transform(input) {
        // eslint-disable-next-line eqeqeq
        if (input == '')
            return '\u00A0';
        return input;
    }
}
EmptyValueFilterPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: EmptyValueFilterPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
EmptyValueFilterPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: EmptyValueFilterPipe, name: "emptyValue" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: EmptyValueFilterPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'emptyValue' }]
        }] });

class StartEditDirective {
    constructor(logFactory) {
        this.log = logFactory.getLogger('StartEditDirective');
    }
    onFocus(e) {
        if (!this.hostComponent) {
            this.log.error('host component not found for the start edit directive use [hostComponent]="self" besides this in the template (component must be extending ServoyBaseComponent)');
        }
        else if (this.hostComponent.servoyApi && this.dataProviderID !== undefined) {
            this.hostComponent.servoyApi.startEdit(this.dataProviderID);
        }
        else {
            this.log.error('Can\'t call startEdit, missing servoyApi and dataProviderID for field ' + this.hostComponent);
        }
    }
}
StartEditDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: StartEditDirective, deps: [{ token: LoggerFactory }], target: i0.ɵɵFactoryTarget.Directive });
StartEditDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: StartEditDirective, selector: "[svyStartEdit]", inputs: { dataProviderID: ["svyStartEdit", "dataProviderID"], hostComponent: "hostComponent" }, host: { listeners: { "focus": "onFocus($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: StartEditDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[svyStartEdit]'
                }]
        }], ctorParameters: function () { return [{ type: LoggerFactory }]; }, propDecorators: { dataProviderID: [{
                type: Input,
                args: ['svyStartEdit']
            }], hostComponent: [{
                type: Input
            }], onFocus: [{
                type: HostListener,
                args: ['focus', ['$event']]
            }] } });

class ImageMediaIdDirective {
    constructor(_elemRef, _renderer) {
        this._elemRef = _elemRef;
        this._renderer = _renderer;
        this.clearStyle = new Map();
        this.clearStyle.set('width', '0px');
        this.clearStyle.set('height', '0px');
        this.clearStyle.set('backgroundImage', '');
    }
    ngOnChanges(changes) {
        if (changes['hostComponent']) {
            this.hostComponent.addViewStateListener(this);
        }
    }
    ngOnDestroy() {
        if (this.hostComponent) {
            this.hostComponent.removeViewStateListener(this);
        }
    }
    afterViewInit() {
        const nativeElement = this.hostComponent.getNativeElement();
        const renderer = this.hostComponent.getRenderer();
        renderer.listen(nativeElement, 'mouseenter', (e) => {
            if (this.rollOverImgStyle) {
                this.setCSSStyle(this.rollOverImgStyle);
            }
        });
        renderer.listen(nativeElement, 'mouseleave', (e) => {
            if (this.rollOverImgStyle) {
                if (this.imgStyle) {
                    this.setCSSStyle(this.imgStyle);
                }
                else {
                    this.setCSSStyle(this.clearStyle);
                }
            }
        });
        this.setImageStyle();
    }
    setImageStyle() {
        if (this.media && (this.media.img || this.media.rollOverImg) || this.rollOverImgStyle || this.imgStyle) {
            const componentSize = {
                width: this._elemRef.nativeElement.parentNode.parentNode.clientWidth,
                height: this._elemRef.nativeElement.parentNode.parentNode.clientHeight
            };
            if (componentSize.height === 0 || componentSize.width === 0)
                setTimeout(() => this.setImageStyle(), 100);
            else {
                const mediaOptions = this.media.mediaOptions;
                if (this.media.rollOverImg) {
                    this.rollOverImgStyle = this.parseImageOptions(this.media.rollOverImg, mediaOptions, componentSize);
                }
                else {
                    this.rollOverImgStyle = null;
                }
                if (this.media.img) {
                    this.imgStyle = this.parseImageOptions(this.media.img, mediaOptions, componentSize);
                    this.setCSSStyle(this.imgStyle);
                }
                else {
                    this.imgStyle = null;
                    this.setCSSStyle(this.clearStyle);
                }
            }
        }
    }
    parseImageOptions(image, mediaOptions, componentSize) {
        const bgstyle = new Map();
        bgstyle.set('background-image', 'url(\'' + image + '\')');
        bgstyle.set('background-repeat', 'no-repeat');
        bgstyle.set('background-position', 'left');
        bgstyle.set('display', 'inline-block');
        bgstyle.set('vertical-align', 'middle');
        if (mediaOptions === undefined)
            mediaOptions = 14; // reduce-enlarge & keep aspect ration
        const mediaKeepAspectRatio = mediaOptions === 0 || ((mediaOptions & 8) === 8);
        // default  img size values
        let imgWidth = 16;
        let imgHeight = 16;
        if (image.indexOf('imageWidth=') > 0 && image.indexOf('imageHeight=') > 0) {
            const vars = {};
            image.replace(/[?&]+([^=&]+)=([^&]*)/gi, (m, key, value) => {
                vars[key] = value;
            });
            imgWidth = vars['imageWidth'];
            imgHeight = vars['imageHeight'];
        }
        const widthChange = imgWidth / componentSize.width;
        const heightChange = imgHeight / componentSize.height;
        if (widthChange > 1.01 || heightChange > 1.01 || widthChange < 0.99 || heightChange < 0.99) {
            if ((mediaOptions & 6) === 6) {
                if (mediaKeepAspectRatio) {
                    if (widthChange > heightChange) {
                        imgWidth = imgWidth / widthChange;
                        imgHeight = imgHeight / widthChange;
                    }
                    else {
                        imgWidth = imgWidth / heightChange;
                        imgHeight = imgHeight / heightChange;
                    }
                }
                else {
                    imgWidth = componentSize.width;
                    imgHeight = componentSize.height;
                }
            }
            else if ((mediaOptions & 2) == 2) {
                if (widthChange > 1.01 && heightChange > 1.01) {
                    if (mediaKeepAspectRatio) {
                        if (widthChange > heightChange) {
                            imgWidth = imgWidth / widthChange;
                            imgHeight = imgHeight / widthChange;
                        }
                        else {
                            imgWidth = imgWidth / heightChange;
                            imgHeight = imgHeight / heightChange;
                        }
                    }
                    else {
                        imgWidth = componentSize.width;
                        imgHeight = componentSize.height;
                    }
                }
                else if (widthChange > 1.01) {
                    imgWidth = imgWidth / widthChange;
                    if (mediaKeepAspectRatio) {
                        imgHeight = imgHeight / widthChange;
                    }
                    else {
                        imgHeight = componentSize.height;
                    }
                }
                else if (heightChange > 1.01) {
                    imgHeight = imgHeight / heightChange;
                    if (mediaKeepAspectRatio) {
                        imgWidth = imgWidth / heightChange;
                    }
                    else {
                        imgWidth = componentSize.width;
                    }
                }
            }
            else if ((mediaOptions & 4) == 4) {
                if (widthChange < 0.99 && heightChange < 0.99) {
                    if (mediaKeepAspectRatio) {
                        if (widthChange > heightChange) {
                            imgWidth = imgWidth / widthChange;
                            imgHeight = imgHeight / widthChange;
                        }
                        else {
                            imgWidth = imgWidth / heightChange;
                            imgHeight = imgHeight / heightChange;
                        }
                    }
                    else {
                        imgWidth = componentSize.width;
                        imgHeight = componentSize.height;
                    }
                }
                else if (widthChange < 0.99) {
                    imgWidth = imgWidth / widthChange;
                    if (mediaKeepAspectRatio) {
                        imgHeight = imgHeight / widthChange;
                    }
                    else {
                        imgHeight = componentSize.height;
                    }
                }
                else if (heightChange < 0.99) {
                    imgHeight = imgHeight / heightChange;
                    if (mediaKeepAspectRatio) {
                        imgWidth = imgWidth / heightChange;
                    }
                    else {
                        imgWidth = componentSize.width;
                    }
                }
            }
        }
        bgstyle.set('background-size', mediaKeepAspectRatio ? 'contain' : '100% 100%');
        bgstyle.set('width', Math.round(imgWidth) + 'px');
        bgstyle.set('height', Math.round(imgHeight) + 'px');
        return bgstyle;
    }
    setCSSStyle(cssStyle) {
        cssStyle.forEach((value, key) => {
            this._renderer.setStyle(this._elemRef.nativeElement, key, value);
        });
    }
}
ImageMediaIdDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ImageMediaIdDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
ImageMediaIdDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: ImageMediaIdDirective, selector: "[svyImageMediaId]", inputs: { media: ["svyImageMediaId", "media"], hostComponent: "hostComponent" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ImageMediaIdDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[svyImageMediaId]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { media: [{
                type: Input,
                args: ['svyImageMediaId']
            }], hostComponent: [{
                type: Input
            }] } });

class AutosaveDirective {
    constructor(servoyService, elementRef) {
        this.servoyService = servoyService;
        this.elementRef = elementRef;
    }
    onClick(target) {
        if (target == this.elementRef.nativeElement || target.parentNode == this.elementRef.nativeElement) {
            this.servoyService.callService('applicationServerService', 'autosave', {}, true);
        }
    }
}
AutosaveDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: AutosaveDirective, deps: [{ token: ServoyPublicService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AutosaveDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: AutosaveDirective, selector: "[svyAutosave]", host: { listeners: { "click": "onClick($event.target)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: AutosaveDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[svyAutosave]'
                }]
        }], ctorParameters: function () { return [{ type: ServoyPublicService }, { type: i0.ElementRef }]; }, propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event.target']]
            }] } });

class UploadDirective {
    constructor(servoyService) {
        this.servoyService = servoyService;
        this.propertyName = 'dataProviderID';
    }
    click(e) {
        this.servoyService.showFileOpenDialog('Please select a file', false, null, this.url);
    }
    ngOnInit() {
        this.url = this.servoyService.generateUploadUrl(this.formname, this.componentName, this.propertyName);
    }
}
UploadDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: UploadDirective, deps: [{ token: ServoyPublicService }], target: i0.ɵɵFactoryTarget.Directive });
UploadDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: UploadDirective, selector: "[svyUpload]", inputs: { formname: "formname", componentName: "componentName" }, host: { listeners: { "click": "click()" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: UploadDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[svyUpload]'
                }]
        }], ctorParameters: function () { return [{ type: ServoyPublicService }]; }, propDecorators: { formname: [{
                type: Input
            }], componentName: [{
                type: Input
            }], click: [{
                type: HostListener,
                args: ['click']
            }] } });

const MASK_CONST = {
    // Predefined character definitions
    definitions: {
        '#': '[0-9]',
        0: '[0-9]',
        U: '[A-Z]',
        L: '[a-z]',
        A: '[A-Za-z0-9]',
        '?': '[A-Za-z]',
        '*': '.',
        H: '[A-F0-9]'
    },
    converters: {
        U(c) {
            return c.toUpperCase();
        },
        L(c) {
            return c.toLowerCase();
        },
        H(c) {
            return c.toUpperCase();
        }
    }
};
let MaskFormat = class MaskFormat {
    constructor(format, _renderer, element, formatService, doc) {
        this.format = format;
        this._renderer = _renderer;
        this.element = element;
        this.formatService = formatService;
        this.doc = doc;
        this.firstNonMaskPos = -1;
        this.buffer = [];
        this.tests = [];
        this.converters = [];
        this.ignore = false;
        this.settings = {};
        this.settings['placeholder'] = this.format.placeHolder ? this.format.placeHolder : ' ';
        if (this.format.allowedCharacters)
            this.settings['allowedCharacters'] = this.format.allowedCharacters;
        if (!this.settings['completed']) {
            this.settings['completed'] = null;
        }
        this.mask = this.format.edit;
        //          if (!this.mask && this.element.value.length > 0) { //TODO check condition
        //              return this.buffer.map(function(c, i) { //TODO why return??
        //                  return this.tests[i] ? c : null;
        //              }, this).join('');
        //          }
        let skipNextMask = false;
        this.filteredMask = '';
        const defs = MASK_CONST.definitions;
        const converts = MASK_CONST.converters;
        this.converters = [];
        let partialPosition = this.mask.length;
        let len = this.mask.length;
        const chars = this.mask.split('');
        for (let i = 0; i < chars.length; i++) {
            const c = chars[i];
            //            if (c == '?') {
            //                len--;
            //                partialPosition = i;
            //            } else
            if (!skipNextMask && c === '\'') {
                skipNextMask = true;
                len--;
                partialPosition--;
            }
            else {
                if (!skipNextMask && defs[c]) {
                    if (c === '*' && this.settings['allowedCharacters']) {
                        this.tests.push(new RegExp('[' + this.settings['allowedCharacters'] + ']'));
                    }
                    else {
                        this.tests.push(new RegExp(defs[c]));
                    }
                    if (this.firstNonMaskPos === -1)
                        this.firstNonMaskPos = this.tests.length - 1;
                }
                else {
                    this.tests.push(null);
                    skipNextMask = false;
                }
                this.converters.push(converts[c]);
                this.filteredMask += c;
            }
        }
        this.buffer = this.filteredMask.split('').map(function (c, i, array) {
            return this.tests[i] ? this.getPlaceHolder(i) : c;
        }, this);
        this._renderer.listen(this.element, 'input', () => {
            this.setCaret(this.checkVal(true));
        });
        this._renderer.listen(this.element, 'focus', () => this.onFocus());
        this._renderer.listen(this.element, 'blur', () => this.onBlur());
        this._renderer.listen(this.element, 'keypress', (event) => this.onKeypress(event));
        this._renderer.listen(this.element, 'keydown', (event) => this.onKeydown(event));
    }
    onFocus() {
        this.focusText = this.element.value;
        const pos = this.checkVal(true);
        this.writeBuffer();
        setTimeout(() => this.setCaretOnFocus(pos), 0);
    }
    setCaretOnFocus(pos) {
        if (pos !== this.filteredMask.length) {
            this.setCaret(pos);
        }
        else {
            this.setCaret(this.element.selectionStart);
        }
    }
    onBlur() {
        this.checkVal(true);
        if (this.element.value !== this.focusText) {
            this.element.dispatchEvent(new CustomEvent('change', { bubbles: true, detail: { text: () => this.element.value } }));
        }
    }
    onKeypress(e) {
        if (this.formatService.testKeyPressed(e, 13) && e.target.tagName.toUpperCase() === 'INPUT') {
            //do not looses focus, just apply the format and push value
            this.element.dispatchEvent(new CustomEvent('change', { bubbles: true, detail: { text: () => this.element.value } }));
            return true;
        }
        if (this.ignore) {
            this.ignore = false;
            // Fixes Mac FF bug on backspace
            return (e.keyCode === 8) ? false : null;
        }
        // TODO needed? e = e || window.event;
        const k = e.charCode || e.keyCode || e.which;
        const posBegin = this.element.selectionStart;
        const posEnd = this.element.selectionEnd;
        if (e.ctrlKey || e.altKey || e.metaKey) { // Ignore
            return true;
        }
        else if ((k >= 32 && k <= 125) || k > 186) { // typeable characters
            const p = this.seekNext(posBegin - 1);
            if (p < this.mask.length) {
                let c = String.fromCharCode(k);
                if (this.converters[p]) {
                    c = this.converters[p](c);
                }
                if (this.tests[p].test(c)) {
                    //                    shiftR(p);
                    this.buffer[p] = c;
                    this.writeBuffer();
                    const next = this.seekNext(p);
                    this.setCaret(next);
                    if (this.settings['completed'] && next == this.mask.length)
                        this.settings['completed'].call(this.element);
                }
            }
        }
        return false;
    }
    onKeydown(e) {
        const iPhone = (window.orientation !== undefined);
        let posBegin = this.element.selectionStart;
        let posEnd = this.element.selectionEnd;
        const k = e.keyCode;
        this.ignore = (k < 16 || (k > 16 && k < 32) || (k > 32 && k < 41));
        if (k === 37) {
            const nextValidChar = this.seekPrevious(posBegin);
            if (nextValidChar !== posBegin) {
                this.setCaret(nextValidChar);
                return false;
            }
            return;
        }
        else if (k === 39) {
            const nextValidChar = this.seekNext(posBegin);
            if (nextValidChar !== posBegin) {
                this.setCaret(nextValidChar);
                return false;
            }
            return;
        }
        else {
            const nextValidChar = this.seekNext(posBegin - 1) - posBegin;
            if (nextValidChar > 0) {
                posBegin += nextValidChar;
                posEnd += nextValidChar;
            }
        }
        // backspace, delete, and escape get special treatment
        if (k === 8 || k === 46 || (iPhone && k === 127)) {
            if (posBegin === posEnd) {
                this.clear(posBegin + (k === 46 ? 0 : -1), (k === 46 ? 1 : 0));
            }
            else {
                this.clearBuffer(posBegin, posEnd);
                this.writeBuffer();
                this.setCaret(Math.max(this.firstNonMaskPos, posBegin));
            }
            return false;
        }
        else if (k === 27) { // escape
            this.element.value = this.focusText;
            this.setCaret(0, this.checkVal());
            return false;
        }
        else if (posBegin !== posEnd && !this.ignore) {
            this.clearBuffer(posBegin, posEnd);
        }
    }
    setCaret(begin, end) {
        if (this.element.value.length === 0)
            return;
        if (typeof begin === 'number') {
            end = (typeof end === 'number') ? end : begin;
            if (this.element != null) {
                if (this.element['createTextRange']) {
                    const range = this.element['createTextRange']();
                    range.move('character', begin);
                    range.select();
                }
                else if (this.element.selectionStart >= 0) {
                    this.element.setSelectionRange(begin, end);
                }
            }
        }
        else {
            if (this.element['setSelectionRange']) {
                begin = this.element.selectionStart;
                end = this.element.selectionEnd;
            }
            else if (this.doc.getSelection() && this.doc.getSelection()['createRange']) {
                const range = this.doc.getSelection()['createRange']();
                begin = 0 - range.duplicate().moveStart('character', -100000);
                end = begin + range.text.length;
            }
            return { begin, end };
        }
    }
    seekPrevious(pos) {
        while (--pos >= 0 && !this.tests[pos])
            ;
        return pos;
    }
    seekNext(pos) {
        while (++pos <= this.mask.length && !this.tests[pos])
            ;
        return pos;
    }
    clear(pos, caretAddition) {
        while (!this.tests[pos] && --pos >= 0)
            ;
        if (this.tests[pos]) {
            this.buffer[pos] = this.getPlaceHolder(pos);
        }
        this.writeBuffer();
        if (caretAddition !== 0) {
            let nextPos = pos + caretAddition;
            while (nextPos >= 0 && nextPos < this.mask.length) {
                if (this.tests[nextPos]) {
                    pos = nextPos;
                    break;
                }
                nextPos = nextPos + caretAddition;
            }
        }
        this.setCaret(Math.max(this.firstNonMaskPos, pos));
    }
    clearBuffer(start, end) {
        for (let i = start; i < end && i < this.mask.length; i++) {
            if (this.tests[i])
                this.buffer[i] = this.getPlaceHolder(i);
        }
    }
    writeBuffer() {
        this.element.value = this.buffer.join('');
        return this.element.value;
    }
    checkVal(allow = false) {
        // try to place characters where they belong
        const partialPosition = this.mask.length;
        const test = this.element.value;
        let lastMatch = -1;
        let firstError = -1;
        for (let i = 0, pos = 0; i < this.mask.length; i++) {
            if (this.tests[i]) {
                this.buffer[i] = this.getPlaceHolder(i);
                while (pos++ < test.length) {
                    const c = test.charAt(pos - 1);
                    // if the char is the place holder then dont shift..
                    if (c === this.buffer[i]) {
                        if (firstError === -1)
                            firstError = i;
                        break;
                    }
                    if (this.tests[i].test(c)) {
                        this.buffer[i] = c;
                        lastMatch = i;
                        break;
                    }
                }
                if (pos > test.length)
                    break;
            }
            else if (this.buffer[i] === test.charAt(pos) && i !== partialPosition) {
                pos++;
                //                    lastMatch = i;
            }
        }
        if (!allow && lastMatch + 1 < partialPosition) {
            this.element.value = '';
            this.clearBuffer(0, this.mask.length);
        }
        else if (allow && lastMatch === -1) {
            this.element.value = '';
            this.clearBuffer(0, this.mask.length);
        }
        else if (allow || lastMatch + 1 >= partialPosition) {
            this.writeBuffer();
            if (!allow)
                this.element.value = this.element.value.substring(0, lastMatch + 1);
        }
        return firstError !== -1 ? firstError : (partialPosition ? lastMatch : this.firstNonMaskPos);
    }
    getPlaceHolder(i) {
        return this.settings['placeholder'].length > 1 ? this.settings['placeholder'].charAt(i) : this.settings['placeholder'];
    }
};
MaskFormat = __decorate([
    __param(4, Inject(DOCUMENT))
], MaskFormat);

class NumberParser {
    constructor() {
        const locale = new Intl.NumberFormat().resolvedOptions().locale;
        const parts = new Intl.NumberFormat(locale).formatToParts(12345.6);
        const numerals = [...new Intl.NumberFormat(locale, { useGrouping: false }).format(9876543210)].reverse();
        const index = new Map(numerals.map((d, i) => [d, i]));
        this._group = new RegExp(`[${parts.find(d => d.type === 'group').value}]`, 'g');
        this._decimal = new RegExp(`[${parts.find(d => d.type === 'decimal').value}]`);
        this._numeral = new RegExp(`[${numerals.join('')}]`, 'g');
        this._index = d => index.get(d).toString();
    }
    parse(str) {
        return (str.trim().replace(this._group, '').replace(this._decimal, '.').replace(this._numeral, this._index)) ? +str : NaN;
    }
}
class FormatDirective {
    constructor(_renderer, _elementRef, formatService, doc, logFactory) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.formatService = formatService;
        this.doc = doc;
        this.hasFocus = false;
        this.realValue = null;
        this.isKeyPressEventFired = false;
        this.oldInputValue = null;
        this.listeners = [];
        this.onChangeCallback = (_) => { };
        this.onTouchedCallback = () => { };
        this.log = logFactory.getLogger('formatdirective');
    }
    touched() {
        this.onTouchedCallback();
        this.hasFocus = false;
        if (this.format.display && this.format.edit && this.format.edit !== this.format.display) {
            this.writeValue(this.realValue);
        }
    }
    focussed() {
        this.hasFocus = true;
        if (this.format.display && this.format.edit && this.format.edit !== this.format.display) {
            this.writeValue(this.realValue);
        }
    }
    input(value) {
        let data = value;
        const inputType = this.getType();
        if (inputType === 'datetime-local') {
            data = this.formatService.unformat(value, FormatDirective.DATETIMEFORMAT.display, FormatDirective.DATETIMEFORMAT.type, this.realValue);
        }
        else if (inputType === 'date') {
            data = this.formatService.unformat(value, FormatDirective.DATEFORMAT.display, FormatDirective.DATEFORMAT.type, this.realValue);
        }
        else if (inputType === 'time') {
            data = this.formatService.unformat(value, FormatDirective.TIMEFORMAT.display, FormatDirective.TIMEFORMAT.type, this.realValue);
        }
        else if (inputType === 'month') {
            data = this.formatService.unformat(value, FormatDirective.MONTHFORMAT.display, FormatDirective.MONTHFORMAT.type, this.realValue);
        }
        else if (inputType === 'week') {
            data = this.formatService.unformat(value, FormatDirective.WEEKFORMAT.display, FormatDirective.WEEKFORMAT.type, this.realValue);
        }
        else if (inputType === 'number') {
            data = FormatDirective.BROWSERNUMBERFORMAT.parse(value);
        }
        else if (inputType === 'email') {
            data = value;
        }
        else if (!this.findmode && this.format) {
            const type = this.format.type;
            let format = this.format.display ? this.format.display : this.format.edit;
            if (this.hasFocus && this.format.edit && !this.format.isMask)
                format = this.format.edit;
            try {
                data = this.formatService.unformat(data, format, type, this.realValue);
            }
            catch (e) {
                this.log.error(e);
                //TODO set error state
            }
            if (this.format.type === 'TEXT' && this.format.isRaw && this.format.isMask) {
                if (data && format && data.length === format.length) {
                    let ret = '';
                    for (let i = 0; i < format.length; i++) {
                        switch (format[i]) {
                            case 'U':
                            case 'L':
                            case 'A':
                            case '?':
                            case '*':
                            case 'H':
                            case '#':
                                ret += data[i];
                                break;
                            default:
                                // ignore literal characters
                                break;
                        }
                    }
                    data = ret;
                }
            }
        }
        this.realValue = data;
        this.onChangeCallback(data);
    }
    ngAfterViewInit() {
        this.setFormat();
    }
    ngOnChanges() {
        this.setFormat();
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    writeValue(value) {
        this.realValue = value;
        const inputType = this.getType();
        if (inputType === 'datetime-local') {
            const data = this.formatService.format(value, FormatDirective.DATETIMEFORMAT, false);
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else if (inputType === 'date') {
            const data = this.formatService.format(value, FormatDirective.DATEFORMAT, false);
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else if (inputType === 'time') {
            const data = this.formatService.format(value, FormatDirective.TIMEFORMAT, false);
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else if (inputType === 'month') {
            const data = this.formatService.format(value, FormatDirective.MONTHFORMAT, false);
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else if (inputType === 'week') {
            const data = this.formatService.format(value, FormatDirective.WEEKFORMAT, false);
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else if (inputType === 'number') {
            const data = value ? new Intl.NumberFormat().format(value) : '';
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else if (inputType === 'email') {
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
        }
        else if (value && this.format) {
            let data = value;
            if (!this.findmode) {
                data = inputType === 'number' && data.toString().length >= this.format.maxLength ? data.toString().substring(0, this.format.maxLength) : data;
                let useEdit = !this.format.display;
                if (this.format.edit && !this.format.isMask && this.hasFocus)
                    useEdit = true;
                try {
                    data = this.formatService.format(data, this.format, useEdit);
                }
                catch (e) {
                    this.log.error(e);
                }
                if (data && this.format.type === 'TEXT') {
                    if (this.format.uppercase)
                        data = data.toUpperCase();
                    else if (this.format.lowercase)
                        data = data.toLowerCase();
                }
            }
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
        }
        else {
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', value ? value : '');
        }
    }
    getType() {
        const type = this._elementRef.nativeElement.type;
        return type ? type.toLocaleLowerCase() : 'text';
    }
    setFormat() {
        this.listeners.forEach(lFn => lFn());
        this.listeners = [];
        if (this.format) {
            if (!this.findmode && (this.format.uppercase || this.format.lowercase)) {
                this.listeners.push(this._renderer.listen(this._elementRef.nativeElement, 'input', () => this.upperOrLowerCase()));
            }
            if (this.format.isNumberValidator || this.format.type === 'NUMBER' || this.format.type === 'INTEGER') {
                this.listeners.push(this._renderer.listen(this._elementRef.nativeElement, 'keypress', (event) => {
                    this.isKeyPressEventFired = true;
                    return this.formatService.testForNumbersOnly(event, null, this._elementRef.nativeElement, this.findmode, true, this.format, false);
                }));
                this.listeners.push(this._renderer.listen(this._elementRef.nativeElement, 'input', (event) => this.inputFiredForNumbersCheck(event)));
            }
            if (this.format.maxLength) {
                if (!this.findmode) {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'maxlength', this.format.maxLength + '');
                }
                else {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'maxlength');
                }
            }
            if (!this.findmode && this.format.isMask) {
                new MaskFormat(this.format, this._renderer, this._elementRef.nativeElement, this.formatService, this.doc);
            }
            this.writeValue(this.realValue);
        }
    }
    // lower and upper case handling
    upperOrLowerCase() {
        const element = this._elementRef.nativeElement;
        const caretPos = element.selectionStart;
        element.value = this.format.uppercase ? element.value.toUpperCase() : element.value.toLowerCase();
        element.setSelectionRange(caretPos, caretPos);
    }
    inputFiredForNumbersCheck(event) {
        let currentValue = this._elementRef.nativeElement.value;
        if (!this.isKeyPressEventFired && event.target.tagName.toUpperCase() === 'INPUT') {
            // get inserted chars
            const inserted = this.findDelta(currentValue, this.oldInputValue);
            // get removed chars
            const removed = this.findDelta(this.oldInputValue, currentValue);
            // determine if user pasted content
            const pasted = inserted.length > 1 || (!inserted && !removed);
            if (!pasted && !removed) {
                if (!this.formatService.testForNumbersOnly(event, inserted, this._elementRef.nativeElement, this.findmode, true, this.format, true)) {
                    currentValue = this.oldInputValue;
                }
            }
            //If number validator, check all chars in string and extract only the valid chars.
            if (event.target.type.toUpperCase() === 'NUMBER' || this.format.type === 'NUMBER' || this.format.type === 'INTEGER' || this.format.isNumberValidator) {
                currentValue = this.getNumbersFromString(event, currentValue, this.oldInputValue);
            }
            if (currentValue !== this._elementRef.nativeElement.value) {
                this._elementRef.nativeElement.value = currentValue;
                // // detect IE8 and above, and Edge; call on change manually because of https://bugs.jquery.com/ticket/10818
                // if (/MSIE/.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge/.test(navigator.userAgent)) {
                // 	var changeOnBlurForIE = function() {
                // 		 element.change();
                // 		 element.off("blur", callChangeOnBlur);
                // 	 }
                // 	 element.on("blur", changeOnBlurForIE);
                // }
            }
            this.oldInputValue = currentValue;
            this.isKeyPressEventFired = false;
        }
        if (this.isKeyPressEventFired) {
            this.oldInputValue = currentValue;
            this.isKeyPressEventFired = false;
        }
    }
    findDelta(value, prevValue) {
        let delta = '';
        if (typeof value === 'string' && typeof prevValue === 'string' && value.length >= prevValue.length) {
            for (let i = 0; i < value.length; i++) {
                const str = value.substr(0, i) + value.substr(i + value.length - prevValue.length);
                if (str === prevValue) {
                    delta = value.substr(i, value.length - prevValue.length);
                    break;
                }
            }
        }
        return delta;
    }
    getNumbersFromString(e, currentValue, oldInputValue) {
        if (oldInputValue === currentValue) {
            return currentValue;
        }
        let stripped = '';
        for (let i = 0; i < currentValue.length; i++) {
            if (this.formatService.testForNumbersOnly(e, currentValue.charAt(i), this._elementRef.nativeElement, this.findmode, true, this.format, true)) {
                stripped = stripped + currentValue.charAt(i);
                if (stripped.length === this.format.maxLength)
                    break;
            }
        }
        return stripped;
    }
}
FormatDirective.DATETIMEFORMAT = { display: 'yyyy-MM-ddTHH:mm:ss', type: 'DATETIME' };
FormatDirective.DATEFORMAT = { display: 'yyyy-MM-dd', type: 'DATETIME' };
FormatDirective.MONTHFORMAT = { display: 'yyyy-MM', type: 'DATETIME' };
FormatDirective.WEEKFORMAT = { display: 'YYYY-[W]WW', type: 'DATETIME' };
FormatDirective.TIMEFORMAT = { display: 'HH:mm', type: 'DATETIME' };
FormatDirective.BROWSERNUMBERFORMAT = new NumberParser();
FormatDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormatDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: FormattingService }, { token: DOCUMENT }, { token: LoggerFactory }], target: i0.ɵɵFactoryTarget.Directive });
FormatDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: FormatDirective, selector: "[svyFormat]", inputs: { format: ["svyFormat", "format"], findmode: "findmode" }, host: { listeners: { "blur": "touched()", "focus": "focussed()", "change": "input($event.target.value)" } }, providers: [{
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FormatDirective),
            multi: true
        }], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: FormatDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[svyFormat]',
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FormatDirective),
                            multi: true
                        }]
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: FormattingService }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: LoggerFactory }]; }, propDecorators: { format: [{
                type: Input,
                args: ['svyFormat']
            }], findmode: [{
                type: Input
            }], touched: [{
                type: HostListener,
                args: ['blur', []]
            }], focussed: [{
                type: HostListener,
                args: ['focus', []]
            }], input: [{
                type: HostListener,
                args: ['change', ['$event.target.value']]
            }] } });

class SabloTabseq {
    constructor(_elemRef, cdRef) {
        this._elemRef = _elemRef;
        this.cdRef = cdRef;
        this.designChildIndexToArrayPosition = {};
        this.designChildTabSeq = []; // contains ordered numbers that will be keys in 'runtimeChildIndexes'; can have duplicates
        this.runtimeChildIndexes = {}; // map designChildIndex[i] -> runtimeIndex for child or designChildIndex[i] -> [runtimeIndex1, runtimeIndex2] in case there are multiple equal design time indexes
    }
    // handle event: Child Servoy Tab Sequence registered
    registerChildHandler(designChildIndex, runtimeChildIndex, event) {
        if (this.designTabSeq === -2 || designChildIndex === -2) {
            this.recalculateIndexesHandler(designChildIndex ? designChildIndex : 0, false);
            event.stopPropagation();
            return false;
        }
        // insert it sorted
        let posInDesignArray = 0;
        for (let tz = 0; tz < this.designChildTabSeq.length && this.designChildTabSeq[tz] < designChildIndex; tz++) {
            posInDesignArray = tz + 1;
        }
        if (posInDesignArray === this.designChildTabSeq.length || this.designChildTabSeq[posInDesignArray] > designChildIndex) {
            this.designChildTabSeq.splice(posInDesignArray, 0, designChildIndex);
            // always keep in designChildIndexToArrayPosition[i] the first occurrance of design index i in the sorted designChildTabSeq array
            for (let tz = posInDesignArray; tz < this.designChildTabSeq.length; tz++) {
                this.designChildIndexToArrayPosition[this.designChildTabSeq[tz]] = tz;
            }
            this.runtimeChildIndexes[designChildIndex] = runtimeChildIndex;
        }
        else {
            // its == that means that we have dupliate design indexes; we treat this special - all same design index children as a list in one runtime index array cell
            if (!this.runtimeChildIndexes[designChildIndex].push) {
                this.runtimeChildIndexes[designChildIndex] = [this.runtimeChildIndexes[designChildIndex]];
            }
            this.runtimeChildIndexes[designChildIndex].push(runtimeChildIndex);
        }
        this.recalculateIndexesHandler(designChildIndex ? designChildIndex : 0, false);
        event.stopPropagation();
        return false;
    }
    unregisterChildHandler(designChildIndex, runtimeChildIndex, event) {
        if (this.designTabSeq === -2 || designChildIndex === -2) {
            event.stopPropagation();
            return false;
        }
        const posInDesignArray = this.designChildIndexToArrayPosition[designChildIndex];
        if (posInDesignArray !== undefined) {
            const keyInRuntimeArray = this.designChildTabSeq[posInDesignArray];
            const multipleEqualDesignValues = this.runtimeChildIndexes[keyInRuntimeArray].push;
            if (!multipleEqualDesignValues) {
                delete this.designChildIndexToArrayPosition[designChildIndex];
                for (const tmp in this.designChildIndexToArrayPosition) {
                    if (this.designChildIndexToArrayPosition[tmp] > posInDesignArray)
                        this.designChildIndexToArrayPosition[tmp]--;
                }
                this.designChildTabSeq.splice(posInDesignArray, 1);
                delete this.runtimeChildIndexes[keyInRuntimeArray];
            }
            else {
                this.runtimeChildIndexes[keyInRuntimeArray].splice(this.runtimeChildIndexes[keyInRuntimeArray].indexOf(runtimeChildIndex), 1);
                if (this.runtimeChildIndexes[keyInRuntimeArray].length === 1)
                    this.runtimeChildIndexes[keyInRuntimeArray] = this.runtimeChildIndexes[keyInRuntimeArray][0];
            }
        }
        event.stopPropagation();
        return false;
    }
    // handle event: child tree was now linked or some child needs extra indexes; runtime indexes can be computed starting at the given child;
    // recalculate Parent Servoy Tab Sequence
    recalculateIndexesHandler(designChildIndex, initialRootRecalculate, event) {
        if (this.designTabSeq === -2 || designChildIndex === -2) {
            if (event)
                event.stopPropagation();
            return false;
        }
        if (!this.initializing) {
            // a new child is ready/linked; recalculate tab indexes for it and after it
            const startIdx = (this.designChildIndexToArrayPosition && this.designChildIndexToArrayPosition[designChildIndex] !== undefined) ?
                this.designChildIndexToArrayPosition[designChildIndex] : 0;
            this.recalculateChildRuntimeIndexesStartingAt(startIdx, false);
        }
        else if (initialRootRecalculate) {
            // this is $rootScope (one $parent extra cause the directive creates it); we always assume a sabloTabseq directive is bound to it;
            // now that it is linked we can do initial calculation of tre
            this.runtimeIndex.startIndex = this.runtimeIndex.nextAvailableIndex = 1;
            this.recalculateChildRuntimeIndexesStartingAt(0, true);
        } // else wait for parent tabSeq directives to get linked as well
        if (event)
            event.stopPropagation();
        return false;
    }
    disableTabseq(event) {
        this.isEnabled = false;
        this.recalculateChildRuntimeIndexesStartingAt(0, true);
        event.stopPropagation();
        return false;
    }
    enableTabseq(event) {
        this.isEnabled = true;
        this.trigger(this._elemRef.nativeElement.parentNode, 'recalculatePSTS', [0, false]);
        event.stopPropagation();
        return false;
    }
    ngOnInit() {
        // called by angular in parents first then in children
        if (!this.designTabSeq)
            this.designTabSeq = 0;
        this.initializing = true;
        this.isEnabled = true;
        // runtime index -1 == SKIP focus traversal in browser
        // runtime index  0 == DEFAULT == design tab seq 0 (not tabIndex attr set to element or it's children)
        this.runtimeIndex = { startIndex: -1, nextAvailableIndex: -1, sablotabseq: this };
        // -1 runtime initially for all (in case some node in the tree has -2 design (skip) and children have >= 0,
        // at runtime all children should be excluded as wel)
        this.updateCurrentDomElTabIndex();
        // check to see if this is the top-most tabSeq container
        if (this.config && this.config.root) {
            // it's root tab seq container (so no parent); just do initial tree calculation
            this.recalculateIndexesHandler(0, true);
        }
        else {
            if (this.designTabSeq !== -2) {
                this.trigger(this._elemRef.nativeElement.parentNode, 'registerCSTS', [this.designTabSeq, this.runtimeIndex]);
            }
        }
    }
    ngOnChanges(changes) {
        const change = changes['designTabSeq'];
        if (change && !change.firstChange) {
            if (!(this.config && this.config.root)) {
                if (change.previousValue !== -2)
                    this.trigger(this._elemRef.nativeElement.parentNode, 'unregisterCSTS', [change.previousValue, this.runtimeIndex]);
                if (!this.designTabSeq)
                    this.designTabSeq = 0;
                this.runtimeIndex.startIndex = -1;
                this.runtimeIndex.nextAvailableIndex = -1;
                this.initializing = true;
                if (this.designTabSeq !== -2) {
                    this.trigger(this._elemRef.nativeElement.parentNode, 'registerCSTS', [this.designTabSeq, this.runtimeIndex]);
                    // here we could send [0] instead of [designTabSeq] - it would potentially calculate more but start again from first parent available index,
                    // not higher index (the end user behavior being the same)
                    this.trigger(this._elemRef.nativeElement.parentNode, 'recalculatePSTS', [this.designTabSeq]);
                }
                else {
                    this.updateCurrentDomElTabIndex(); // -1 runtime
                }
            }
        }
    }
    recalculateChildRuntimeIndexesStartingAt(posInDesignArray /*inclusive*/, triggeredByParent) {
        if (this.designTabSeq === -2)
            return;
        if (!this.isEnabled || this.runtimeIndex.startIndex === -1) {
            this.runtimeIndex.nextAvailableIndex = this.runtimeIndex.startIndex;
            this.runtimeIndex.startIndex = -1;
        }
        else if (this.designTabSeq === 0) {
            // this element doesn't set any tabIndex attribute (default behavior)
            this.runtimeIndex.nextAvailableIndex = this.runtimeIndex.startIndex;
            this.runtimeIndex.startIndex = 0;
        }
        else if (this.runtimeIndex.startIndex === 0) {
            this.runtimeIndex.nextAvailableIndex = 0;
        }
        else if (this.runtimeIndex.nextAvailableIndex === -1) {
            const reservedGap = (this.config && this.config.reservedGap) ? this.config.reservedGap : 0;
            this.runtimeIndex.nextAvailableIndex = this.runtimeIndex.startIndex + reservedGap;
        }
        if (posInDesignArray === 0)
            this.updateCurrentDomElTabIndex();
        let recalculateStartIndex = this.runtimeIndex.startIndex;
        if (posInDesignArray > 0 && posInDesignArray - 1 < this.designChildTabSeq.length) {
            const runtimeCI = this.runtimeChildIndexes[this.designChildTabSeq[posInDesignArray - 1]]; // this can be an array in case of multiple equal design indexes being siblings
            recalculateStartIndex = runtimeCI.push ? runtimeCI[runtimeCI.length - 1].nextAvailableIndex : runtimeCI.nextAvailableIndex;
        }
        for (let i = posInDesignArray; i < this.designChildTabSeq.length; i++) {
            const childRuntimeIndex = this.runtimeChildIndexes[this.designChildTabSeq[i]];
            if (childRuntimeIndex.push) {
                // multiple equal design time indexes as siblings
                let max = recalculateStartIndex;
                for (const k in childRuntimeIndex) {
                    if (childRuntimeIndex.hasOwnProperty(k)) {
                        childRuntimeIndex[k].startIndex = recalculateStartIndex;
                        // call recalculate on whole child; normally it only makes sense for same index siblings
                        // if they are not themselfes containers, just apply the given value
                        childRuntimeIndex[k].sablotabseq.recalculateChildRuntimeIndexesStartingAt(0, true);
                        if (max < childRuntimeIndex[k].nextAvailableIndex)
                            max = childRuntimeIndex[k].nextAvailableIndex;
                    }
                }
                recalculateStartIndex = max;
            }
            else {
                childRuntimeIndex.startIndex = recalculateStartIndex;
                childRuntimeIndex.sablotabseq.recalculateChildRuntimeIndexesStartingAt(0, true); // call recalculate on whole child
                recalculateStartIndex = childRuntimeIndex.nextAvailableIndex;
            }
        }
        if (this.initializing)
            this.initializing = undefined; // it's now considered initialized as first runtime index caluculation is done
        let parentRecalculateNeeded;
        if (this.runtimeIndex.startIndex !== 0 && this.runtimeIndex.startIndex !== -1) {
            const ownTabIndexBump = this.hasOwnTabIndex() ? 1 : 0;
            parentRecalculateNeeded = (this.runtimeIndex.nextAvailableIndex < recalculateStartIndex + ownTabIndexBump);
            const reservedGap = (this.config && this.config.reservedGap) ? this.config.reservedGap : 0;
            if (parentRecalculateNeeded)
                this.runtimeIndex.nextAvailableIndex = recalculateStartIndex + reservedGap + ownTabIndexBump;
        }
        else {
            // start index 0 means default (no tabIndex attr. set)
            parentRecalculateNeeded = false;
        }
        // if this container now needs more tab indexes than it was reserved; a recalculate on parent needs to be triggered in this case
        if (parentRecalculateNeeded && !triggeredByParent)
            this.trigger(this._elemRef.nativeElement.parentNode, 'recalculatePSTS', [this.designTabSeq, false]);
    }
    hasOwnTabIndex() {
        return (!this.config || !(this.config.container || this.config.root));
    }
    updateCurrentDomElTabIndex() {
        if (this.hasOwnTabIndex()) {
            if (this.runtimeIndex.startIndex !== 0) {
                this.setDOMTabIndex(this.runtimeIndex.startIndex);
            }
            else {
                this.setDOMTabIndex(undefined);
            }
        }
    }
    setDOMTabIndex(tabindex) {
        this.tabindex = tabindex;
        this.cdRef.detectChanges();
    }
    trigger(target, event, arg) {
        const customEvent = new CustomEvent(event, {
            bubbles: true,
            detail: arg
        });
        target.dispatchEvent(customEvent);
    }
    ngOnDestroy() {
        // unregister current tabSeq from parent tabSeq container
        if (this._elemRef.nativeElement.parentNode) {
            this.trigger(this._elemRef.nativeElement.parentNode, 'unregisterCSTS', [this.designTabSeq, this.runtimeIndex]);
        }
    }
}
SabloTabseq.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SabloTabseq, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
SabloTabseq.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: SabloTabseq, selector: "[sabloTabseq]", inputs: { designTabSeq: ["sabloTabseq", "designTabSeq"], config: ["sabloTabseqConfig", "config"] }, host: { listeners: { "registerCSTS": "registerChildHandler($event.detail[0],$event.detail[1],$event)", "unregisterCSTS": "unregisterChildHandler($event.detail[0],$event.detail[1],$event)", "recalculatePSTS": "recalculateIndexesHandler($event.detail[0],$event.detail[1],$event)", "disableTabseq": "disableTabseq($event)", "enableTabseq": "enableTabseq($event)" }, properties: { "attr.tabindex": "this.tabindex" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SabloTabseq, decorators: [{
            type: Directive,
            args: [{
                    selector: '[sabloTabseq]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { designTabSeq: [{
                type: Input,
                args: ['sabloTabseq']
            }], config: [{
                type: Input,
                args: ['sabloTabseqConfig']
            }], tabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], registerChildHandler: [{
                type: HostListener,
                args: ['registerCSTS', ['$event.detail[0]', '$event.detail[1]', '$event']]
            }], unregisterChildHandler: [{
                type: HostListener,
                args: ['unregisterCSTS', ['$event.detail[0]', '$event.detail[1]', '$event']]
            }], recalculateIndexesHandler: [{
                type: HostListener,
                args: ['recalculatePSTS', ['$event.detail[0]', '$event.detail[1]', '$event']]
            }], disableTabseq: [{
                type: HostListener,
                args: ['disableTabseq', ['$event']]
            }], enableTabseq: [{
                type: HostListener,
                args: ['enableTabseq', ['$event']]
            }] } });

class SpecTypesService {
    constructor(logFactory) {
        this.registeredTypes = new Map();
        this.log = logFactory.getLogger('SpecTypesService');
    }
    createType(name) {
        const classRef = this.registeredTypes.get(name);
        if (classRef) {
            return new classRef();
        }
        this.log.warn('returning just the basic custom object for  ' + name + ' none of the properties will be monitored');
        return new BaseCustomObject();
    }
    enhanceArrayType(array, iterableDiffers) {
        if (!instanceOfChangeAwareValue(array)) {
            array['stateHolder'] = new ArrayState(array, iterableDiffers);
            Object.defineProperty(array, 'getStateHolder', {
                enumerable: false,
                value() {
                    return this.stateHolder;
                }
            });
            Object.defineProperty(array, 'markForChanged', {
                enumerable: false,
                value() {
                    this.stateHolder.notifyChangeListener();
                }
            });
            array['stateHolder'].initDiffer();
        }
        return array;
    }
    registerType(name, classRef) {
        this.registeredTypes.set(name, classRef);
    }
    guessType(val) {
        let guess = null;
        if (instanceOfCustomArray(val)) {
            guess = 'JSON_arr';
        }
        else if (instanceOfBaseCustomObject(val)) {
            guess = 'JSON_obj';
        } // else TODO do any other types need guessing?
        //        else { // try to find it in types?
        //            this.registeredTypes.forEach(function(typeConstructorValue, typeNameKey) {
        //                if (val instanceof typeConstructorValue) guess = typeNameKey; // this wouldn't return the converter name like 'JSON_obj' but rather the actual name from spec
        //                of the custom type like "(...).tab"
        //            });
        //        }
        return guess;
    }
}
SpecTypesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SpecTypesService, deps: [{ token: LoggerFactory }], target: i0.ɵɵFactoryTarget.Injectable });
SpecTypesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SpecTypesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: SpecTypesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: LoggerFactory }]; } });
function isChanged(now, prev, conversionInfo) {
    if ((typeof conversionInfo === 'string' || typeof conversionInfo === 'number') && instanceOfChangeAwareValue(now)) {
        return now.getStateHolder().hasChanges();
    }
    if (now === prev)
        return false;
    if (now && prev) {
        if (now instanceof Array) {
            if (prev instanceof Array) {
                if (now.length !== prev.length)
                    return true;
            }
            else {
                return true;
            }
        }
        if (now instanceof Date) {
            if (prev instanceof Date) {
                return now.getTime() !== prev.getTime();
            }
            return true;
        }
        if ((now instanceof Object) && (prev instanceof Object)) {
            // first build up a list of all the properties both have.
            const fulllist = this.getCombinedPropertyNames(now, prev);
            for (const prop in fulllist) {
                // ng repeat creates a child scope for each element in the array any scope has a $$hashKey property which must be ignored since it is not part of the model
                if (prev[prop] !== now[prop]) {
                    if (prop === '$$hashKey')
                        continue;
                    if (typeof now[prop] === 'object') {
                        if (isChanged(now[prop], prev[prop], conversionInfo ? conversionInfo[prop] : undefined)) {
                            return true;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    return true;
}
const instanceOfChangeAwareValue = (obj) => obj != null && (obj).getStateHolder instanceof Function;
const instanceOfCustomArray = (obj) => instanceOfChangeAwareValue(obj) && obj.markForChanged instanceof Function;
const instanceOfBaseCustomObject = (obj) => instanceOfChangeAwareValue(obj) && (obj).getStateHolder() instanceof BaseCustomObjectState;
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["ROWS_CHANGED"] = 0] = "ROWS_CHANGED";
    /**
     * When an INSERT happened but viewport size remained the same, it is
     * possible that some of the rows that were previously at the end of the viewport
     * slided out of it;
     * NOTE: insert signifies an insert into the client viewport, not necessarily
     * an insert in the foundset itself; for example calling "loadExtraRecordsAsync"
     * can result in an insert notification + bigger viewport size notification
     */
    ChangeType[ChangeType["ROWS_INSERTED"] = 1] = "ROWS_INSERTED";
    /**
     * When a DELETE happened inside the viewport but there were more rows available in the
     * foundset after current viewport, it is possible that some of those rows
     * slided into the viewport;
     * NOTE: delete signifies a delete from the client viewport, not necessarily
     * a delete in the foundset itself; for example calling "loadLessRecordsAsync" can
     * result in a delete notification + smaller viewport size notification
     */
    ChangeType[ChangeType["ROWS_DELETED"] = 2] = "ROWS_DELETED";
})(ChangeType || (ChangeType = {}));
class BaseCustomObject {
    constructor() {
        this.state = new BaseCustomObjectState();
        this.state.allChanged = true;
    }
    getStateHolder() {
        return this.state;
    }
    /**
     *  subclasses can override this to give back the properties that needs to be watched.
     */
    getWatchedProperties() {
        return null;
    }
}
;
class ChangeAwareState {
    constructor() {
        this.allChanged = false;
        this.inNotify = false;
    }
    markAllChanged(notifyListener) {
        this.allChanged = true;
        if (notifyListener)
            this.notifyChangeListener();
    }
    hasChanges() {
        return this.allChanged || this.inNotify;
    }
    setChangeListener(callback) {
        this.changeListener = callback;
    }
    notifyChangeListener() {
        this.inNotify = true;
        if (this.changeListener)
            this.changeListener();
        this.inNotify = false;
    }
}
class BaseCustomObjectState extends ChangeAwareState {
    constructor() {
        super(...arguments);
        this.conversionInfo = {};
        this.ignoreChanges = false;
        this.change = 0;
        this.hash = BaseCustomObjectState.counter++;
        this.changedKeys = new Set();
    }
    hasChanges() {
        return super.hasChanges() || this.getChangedKeys().size > 0; // leave this as a method call as some subclasses might compute the changedKeys inside getChangedKeys()
    }
    setPropertyAndHandleChanges(_thisBaseCustoomObject, internalPropertyName, propertyName, value) {
        const oldValue = _thisBaseCustoomObject[internalPropertyName];
        // if the value of this property is changed, mark it as such and notify if needed
        this.markIfChanged(propertyName, value, oldValue);
        // unregister as listener to old value if needed
        this.setChangeListenerToSubValueIfNeeded(oldValue, undefined);
        _thisBaseCustoomObject[internalPropertyName] = value;
        // register as listener to new value if needed
        this.setChangeListenerToSubValueIfNeeded(value, () => {
            this.markIfChanged(propertyName, value, value);
        });
        // this value has changed by reference; so it needs to be fully sent to server - except for when it now arrived from the server and is being set (in which case ignoreChanges is true)
        if (!this.ignoreChanges && instanceOfChangeAwareValue(value))
            value.getStateHolder().markAllChanged(false);
    }
    getChangedKeys() {
        return this.changedKeys;
    }
    clearChanges() {
        this.changedKeys.clear();
        this.allChanged = false;
    }
    getHashKey() {
        return this.hash + '_' + this.change;
    }
    markIfChanged(propertyName, newObject, oldObject) {
        if (this.testChanged(propertyName, newObject, oldObject)) {
            this.pushChange(propertyName);
            return true;
        }
        return false;
    }
    setChangeListenerToSubValueIfNeeded(value, changeListener) {
        if (instanceOfChangeAwareValue(value)) {
            // child is able to handle it's own change mechanism
            value.getStateHolder().setChangeListener(changeListener);
        }
    }
    pushChange(propertyName) {
        if (this.ignoreChanges)
            return;
        if (this.changedKeys.size === 0)
            this.change++;
        if (!this.changedKeys.has(propertyName)) {
            this.changedKeys.add(propertyName);
            this.notifyChangeListener();
        }
    }
    testChanged(propertyName, newObject, oldObject) {
        if (newObject !== oldObject)
            return true;
        if (typeof newObject == 'object') {
            if (instanceOfChangeAwareValue(newObject)) {
                return newObject.getStateHolder().hasChanges();
            }
            else {
                return isChanged(newObject, oldObject, this.conversionInfo[propertyName]);
            }
        }
        return false;
    }
}
// provide a hash that lets arrays that contain custom objects know that the object has changed or not
BaseCustomObjectState.counter = 0;
class ArrayState extends BaseCustomObjectState {
    constructor(array, iterableDiffers) {
        super();
        this.array = array;
        this.iterableDiffers = iterableDiffers;
        this.allChanged = true;
    }
    initDiffer() {
        this.differ = this.iterableDiffers.find(this.array).create((index, item) => {
            if (instanceOfBaseCustomObject(item)) {
                return item.getStateHolder().getHashKey();
            }
            return item;
        });
        this.differ.diff(this.array);
    }
    clearChanges() {
        super.clearChanges();
        this.initDiffer();
    }
    getChangedKeys() {
        let changes = super.getChangedKeys();
        const arrayChanges = this.differ.diff(this.array);
        if (arrayChanges) {
            let addedOrRemoved = 0;
            arrayChanges.forEachAddedItem((record) => {
                addedOrRemoved++;
                changes.add(record.currentIndex);
            });
            arrayChanges.forEachRemovedItem((record) => {
                addedOrRemoved--;
                changes.add(record.previousIndex);
            });
            arrayChanges.forEachMovedItem((record) => {
                if (instanceOfChangeAwareValue(record.item)) {
                    return record.item.getStateHolder().markAllChanged(false);
                }
            });
            if (addedOrRemoved !== 0) {
                // size changed, for now send whole array
                this.markAllChanged(false);
            }
            else {
                const changesArray = Array.from(changes);
                changesArray.sort((a, b) => a - b);
                changes = new Set(changesArray);
            }
        }
        return changes;
    }
}
;

class ServoyPublicModule {
}
ServoyPublicModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ServoyPublicModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicModule, declarations: [TooltipDirective,
        MnemonicletterFilterPipe,
        NotNullOrEmptyPipe,
        HtmlFilterPipe,
        FormatDirective,
        DecimalkeyconverterDirective,
        FormatFilterPipe,
        EmptyValueFilterPipe,
        StartEditDirective,
        ImageMediaIdDirective,
        AutosaveDirective,
        UploadDirective,
        SabloTabseq,
        TrustAsHtmlPipe], exports: [TooltipDirective,
        MnemonicletterFilterPipe,
        NotNullOrEmptyPipe,
        HtmlFilterPipe,
        FormatDirective,
        DecimalkeyconverterDirective,
        FormatFilterPipe,
        EmptyValueFilterPipe,
        StartEditDirective,
        ImageMediaIdDirective,
        AutosaveDirective,
        UploadDirective,
        SabloTabseq,
        TrustAsHtmlPipe] });
ServoyPublicModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicModule, providers: [TooltipService, FormattingService, ComponentContributor, SpecTypesService, WindowRefService, LoggerFactory], imports: [[]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TooltipDirective,
                        MnemonicletterFilterPipe,
                        NotNullOrEmptyPipe,
                        HtmlFilterPipe,
                        FormatDirective,
                        DecimalkeyconverterDirective,
                        FormatFilterPipe,
                        EmptyValueFilterPipe,
                        StartEditDirective,
                        ImageMediaIdDirective,
                        AutosaveDirective,
                        UploadDirective,
                        SabloTabseq,
                        TrustAsHtmlPipe
                    ],
                    imports: [],
                    exports: [TooltipDirective,
                        MnemonicletterFilterPipe,
                        NotNullOrEmptyPipe,
                        HtmlFilterPipe,
                        FormatDirective,
                        DecimalkeyconverterDirective,
                        FormatFilterPipe,
                        EmptyValueFilterPipe,
                        StartEditDirective,
                        ImageMediaIdDirective,
                        AutosaveDirective,
                        UploadDirective,
                        SabloTabseq,
                        TrustAsHtmlPipe
                    ],
                    providers: [TooltipService, FormattingService, ComponentContributor, SpecTypesService, WindowRefService, LoggerFactory]
                }]
        }] });

const scrollbarConstants = {
    SCROLLBARS_WHEN_NEEDED: 0,
    VERTICAL_SCROLLBAR_AS_NEEDED: 1,
    VERTICAL_SCROLLBAR_ALWAYS: 2,
    VERTICAL_SCROLLBAR_NEVER: 4,
    HORIZONTAL_SCROLLBAR_AS_NEEDED: 8,
    HORIZONTAL_SCROLLBAR_ALWAYS: 16,
    HORIZONTAL_SCROLLBAR_NEVER: 32
};
class PropertyUtils {
    static setHorizontalAlignment(element, renderer, halign) {
        if (halign !== -1) {
            if (halign === 0) {
                renderer.setStyle(element, 'text-align', 'center');
            }
            else if (halign === 4) {
                renderer.setStyle(element, 'text-align', 'right');
            }
            else {
                renderer.setStyle(element, 'text-align', 'left');
            }
        }
    }
    static setRotation(element, renderer, rotation, size) {
        const r = 'rotate(' + rotation + 'deg)';
        renderer.setStyle(element, '-moz-transform', r);
        renderer.setStyle(element, '-webkit-transform', r);
        renderer.setStyle(element, '-o-transform', r);
        renderer.setStyle(element, '-ms-transform', r);
        renderer.setStyle(element, 'transform', r);
        renderer.setStyle(element, 'position', 'absolute');
        if (rotation === 90 || rotation === 270) {
            renderer.setStyle(element, 'width', size.height + 'px');
            renderer.setStyle(element, 'height', size.width + 'px');
            renderer.setStyle(element, 'left', (size.width - size.height) / 2 + 'px');
            renderer.setStyle(element, 'top', (size.height - size.width) / 2 + 'px');
        }
    }
    static setBorder(element, renderer, newVal) {
        if (typeof newVal !== 'object' || newVal == null) {
            renderer.removeStyle(element, 'border');
            return;
        }
        if (renderer.parentNode(element).nodeName === 'FIELDSET') {
            // unwrap fieldset
            const parent = renderer.parentNode(element);
            renderer.insertBefore(renderer.parentNode(parent), element, parent);
            renderer.removeChild(renderer.parentNode(parent), parent);
        }
        if (newVal.type === 'TitledBorder') {
            const fieldset = renderer.createElement('fieldset');
            renderer.setAttribute(fieldset, 'style', 'padding:1px;margin:0px;border:1px solid silver;width:100%;height:100%');
            const legend = renderer.createElement('legend');
            renderer.setAttribute(legend, 'style', 'border-bottom:0px; margin:0px;width:auto;color:' + newVal.color + ';text-align:' + newVal.titleJustification);
            if (newVal.font) {
                for (const key of Object.keys(newVal.font)) {
                    // keys like 'fontSize' need to be converted into 'font-size'
                    renderer.setStyle(legend, key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(), newVal.font[key]);
                }
            }
            renderer.appendChild(legend, renderer.createText(newVal.title));
            // this is the way it is done in the old ngclient, but the actual component is positioned partially outside the border
            //            var parent = renderer.parentNode(element);
            //            renderer.insertBefore(parent, fieldset, element);
            //            renderer.appendChild(fieldset, legend);
            //            renderer.appendChild(fieldset, element);
            renderer.appendChild(fieldset, legend);
            for (const i in element.childNodes) {
                if (element.childNodes[i].nodeType === 1) {
                    renderer.appendChild(fieldset, element.childNodes[i]);
                }
            }
            renderer.appendChild(element, fieldset);
        }
        else if (newVal.borderStyle) {
            renderer.removeStyle(element, 'border');
            for (const key of Object.keys(newVal.borderStyle)) {
                renderer.setStyle(element, key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(), newVal.borderStyle[key]);
            }
        }
    }
    static setFont(element, renderer, newVal) {
        if (typeof newVal !== 'object' || newVal == null) {
            renderer.removeStyle(element, 'font');
            return;
        }
        renderer.removeStyle(element, 'font');
        for (const key of Object.keys(newVal)) {
            renderer.setStyle(element, key, newVal[key]);
        }
    }
    static setVisible(element, renderer, newVal) {
        let correctElement = element;
        if (renderer.parentNode(renderer.parentNode(element)) === element.closest('.svy-wrapper')) {
            correctElement = renderer.parentNode(renderer.parentNode(element));
        }
        if (newVal === true) {
            // can we improve this ?
            renderer.removeStyle(correctElement, 'display');
        }
        else if (newVal === false) {
            renderer.setStyle(correctElement, 'display', 'none');
        }
    }
    static addSelectOnEnter(element, renderer, doc) {
        renderer.listen(element, 'focus', () => {
            setTimeout(() => {
                // this access "document" directly which shoudn't really be done, but angular doesn't have encapsuled support for testing "is(":focus")"
                const currentFocusedElement = doc.querySelector(':focus');
                if (currentFocusedElement === element)
                    element.select();
            }, 0);
        });
    }
    static getScrollbarsStyleObj(scrollbars) {
        const style = {};
        /* eslint-disable no-bitwise */
        if ((scrollbars & scrollbarConstants.HORIZONTAL_SCROLLBAR_NEVER) === scrollbarConstants.HORIZONTAL_SCROLLBAR_NEVER) {
            style['overflowX'] = 'hidden';
        }
        else if ((scrollbars & scrollbarConstants.HORIZONTAL_SCROLLBAR_ALWAYS) === scrollbarConstants.HORIZONTAL_SCROLLBAR_ALWAYS) {
            style['overflowX'] = 'scroll';
        }
        else {
            style['overflowX'] = 'auto';
        }
        if ((scrollbars & scrollbarConstants.VERTICAL_SCROLLBAR_NEVER) === scrollbarConstants.VERTICAL_SCROLLBAR_NEVER) {
            style['overflowY'] = 'hidden';
        }
        else if ((scrollbars & scrollbarConstants.VERTICAL_SCROLLBAR_ALWAYS) === scrollbarConstants.VERTICAL_SCROLLBAR_ALWAYS) {
            style['overflowY'] = 'scroll'; // $NON-NLS-1$
        }
        else {
            style['overflowY'] = 'auto'; // $NON-NLS-1$
        }
        /* eslint-enable no-bitwise */
        return style;
    }
    static setScrollbars(element, renderer, value) {
        const style = this.getScrollbarsStyleObj(value);
        Object.keys(style).forEach(key => {
            renderer.setStyle(element, key, style[key]);
        });
    }
    // internal function
    static getPropByStringPath(o, s) {
        s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        s = s.replace(/^\./, ''); // strip a leading dot
        const a = s.split('.');
        while (a.length) {
            const n = a.shift();
            if (n in o) {
                o = o[n];
            }
            else {
                return;
            }
            return o;
        }
    }
}

/**
 * Returns a zero-based index for first day of the week, as used by the specified locale
 * e.g. Sunday (returns 0), or Monday (returns 1)
 *
 * @param locale
 * @returns
 */
const getFirstDayOfWeek = (locale) => {
    // from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
    const firstDay = {
        bd: 5,
        mv: 5,
        ae: 6,
        af: 6,
        bh: 6,
        dj: 6,
        dz: 6,
        eg: 6,
        iq: 6,
        ir: 6,
        jo: 6,
        kw: 6,
        ly: 6,
        ma: 6,
        om: 6,
        qa: 6,
        sa: 6,
        sd: 6,
        sy: 6,
        ye: 6,
        ag: 0,
        ar: 0,
        as: 0,
        au: 0,
        br: 0,
        bs: 0,
        bt: 0,
        bw: 0,
        by: 0,
        bz: 0,
        ca: 0,
        cn: 0,
        co: 0,
        dm: 0,
        do: 0,
        et: 0,
        gt: 0,
        gu: 0,
        hk: 0,
        hn: 0,
        id: 0,
        ie: 0,
        il: 0,
        in: 0,
        jm: 0,
        jp: 0,
        ke: 0,
        kh: 0,
        kr: 0,
        la: 0,
        mh: 0,
        mm: 0,
        mo: 0,
        mt: 0,
        mx: 0,
        mz: 0,
        ni: 0,
        np: 0,
        nz: 0,
        pa: 0,
        pe: 0,
        ph: 0,
        pk: 0,
        pr: 0,
        py: 0,
        sg: 0,
        sv: 0,
        th: 0,
        tn: 0,
        tt: 0,
        tw: 0,
        um: 0,
        us: 0,
        ve: 0,
        vi: 0,
        ws: 0,
        za: 0,
        zw: 0
    };
    const split = locale.split('-');
    const country = split.length > 1 ? split[1].toLowerCase() : split[0].toLowerCase();
    const dow = firstDay[country];
    return (dow === undefined) ? 1 : dow; /*Number*/
};
/**
 * Floors the specified date to the beginning of week.
 *
 * @param date
 * @returns
 */
const floorToWeek = (date) => {
    const fd = getFirstDayOfWeek(date.locale);
    const day = date.weekday % 7; // convert to 0=sunday .. 6=saturday
    const dayAdjust = day >= fd ? -day + fd : -day + fd - 7;
    return date.plus({ days: dayAdjust });
};

class ServoyPublicServiceTestingImpl extends ServoyPublicService {
    constructor() {
        super(...arguments);
        this.messages = {};
        this.forms = {};
    }
    addForm(name, formCache) {
        this.forms[name] = formCache;
    }
    getFormCacheByName(containedForm) {
        if (this.forms[containedForm])
            return this.forms[containedForm];
        const form = {
            absolute: true,
            size: { width: 100, height: 100 },
            getComponent: (name) => {
                const comp = {
                    name,
                    model: {}
                };
                return comp;
            }
        };
        return form;
    }
    generateServiceUploadUrl(serviceName, apiFunctionName) {
        return 'resources/upload/1/svy_services/' + serviceName + '/' + apiFunctionName;
    }
    generateUploadUrl(formname, componentName, propertyName) {
        return 'resources/upload/1' +
            (formname ? '/' + formname : '') +
            (componentName ? '/' + componentName : '') +
            (propertyName ? '/' + propertyName : '');
    }
    executeInlineScript(formname, script, params) {
        throw new Error('Method not implemented.');
    }
    addMessage(key, message) {
        this.messages[key] = message;
    }
    getI18NMessages(...keys) {
        const resolvedMessages = {};
        keys.forEach(key => resolvedMessages[key] = this.messages[key] ? this.messages[key] : '');
        return Promise.resolve(resolvedMessages);
    }
    callService(serviceName, methodName, argsObject, async) {
        throw new Error('Method not implemented.');
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale ? this.locale : 'en';
    }
    createJSEvent(event, eventType, contextFilter, contextFilterElement) {
        const ev = new JSEvent();
        ev.eventType = eventType;
        ev.svyType = eventType;
        ev.formName = 'test';
        ev.elementName = 'test';
        ev.timestamp = new Date().getTime();
        return ev;
    }
    showFileOpenDialog(title, multiselect, acceptFilter, url) {
        throw new Error('Method not implemented.');
    }
}
ServoyPublicServiceTestingImpl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicServiceTestingImpl, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
ServoyPublicServiceTestingImpl.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicServiceTestingImpl });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicServiceTestingImpl, decorators: [{
            type: Injectable
        }] });
class ServoyPublicTestingModule {
}
ServoyPublicTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ServoyPublicTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicTestingModule, imports: [ServoyPublicModule], exports: [ServoyPublicModule] });
ServoyPublicTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicTestingModule, providers: [
        ServoyPublicServiceTestingImpl, { provide: ServoyPublicService, useExisting: ServoyPublicServiceTestingImpl }
    ], imports: [[
            ServoyPublicModule
        ], ServoyPublicModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: ServoyPublicTestingModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [],
                    imports: [
                        ServoyPublicModule
                    ],
                    exports: [
                        ServoyPublicModule
                    ],
                    providers: [
                        ServoyPublicServiceTestingImpl, { provide: ServoyPublicService, useExisting: ServoyPublicServiceTestingImpl }
                    ],
                    schemas: []
                }]
        }] });

// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function runOnPushChangeDetection(cf) {
    return __awaiter(this, void 0, void 0, function* () {
        const cd = cf.debugElement.injector.get(ChangeDetectorRef);
        cd.detectChanges();
        return cf.whenStable();
    });
}

/**
 * Generated bundle index. Do not edit.
 */

export { ArrayState, AutosaveDirective, BaseCustomObject, BaseCustomObjectState, ChangeAwareState, ChangeType, ComponentContributor, DecimalkeyconverterDirective, Deferred, EmptyValueFilterPipe, Format, FormatDirective, FormatFilterPipe, FormattingService, HtmlFilterPipe, ImageMediaIdDirective, JSEvent, LogConfiguration, LogLevel, LoggerFactory, LoggerService, MaskFormat, MnemonicletterFilterPipe, NotNullOrEmptyPipe, PropertyUtils, SabloTabseq, ServoyApi, ServoyBaseComponent, ServoyPublicModule, ServoyPublicService, ServoyPublicServiceTestingImpl, ServoyPublicTestingModule, SpecTypesService, StartEditDirective, TooltipDirective, TooltipService, TrustAsHtmlPipe, UploadDirective, WindowRefService, floorToWeek, getFirstDayOfWeek, instanceOfBaseCustomObject, instanceOfChangeAwareValue, instanceOfCustomArray, isChanged, runOnPushChangeDetection };
//# sourceMappingURL=servoy-public.js.map
