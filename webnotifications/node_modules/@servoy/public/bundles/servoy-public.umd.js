(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('@angular/platform-browser'), require('numbro'), require('luxon'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@servoy/public', ['exports', '@angular/core', '@angular/common', 'rxjs', '@angular/platform-browser', 'numbro', 'luxon', '@angular/forms'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.servoy = global.servoy || {}, global.servoy.public = {}), global.ng.core, global.ng.common, global.rxjs, global.ng.platformBrowser, global.numbro, global.luxon, global.ng.forms));
}(this, (function (exports, i0, common, rxjs, i1, numbro, luxon, forms) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var numbro__default = /*#__PURE__*/_interopDefaultLegacy(numbro);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    // eslint-disable-next-line
    var ServoyBaseComponent = /** @class */ (function () {
        function ServoyBaseComponent(renderer, cdRef) {
            this.renderer = renderer;
            this.cdRef = cdRef;
            this.viewStateListeners = new Set();
            this.componentContributor = new ComponentContributor();
        }
        // final method, do not override
        ServoyBaseComponent.prototype.ngOnInit = function () {
            this.initializeComponent();
            this.servoyApi.registerComponent(this);
        };
        // final method, do not override
        ServoyBaseComponent.prototype.ngAfterViewInit = function () {
            this.initializeComponent();
            if (this.elementRef && this.changes) {
                this.svyOnChanges(this.changes);
                this.changes = null;
            }
            this.cdRef.detectChanges();
        };
        // final method, do not override
        ServoyBaseComponent.prototype.ngOnChanges = function (changes) {
            var e_1, _a, e_2, _b;
            this.initializeComponent();
            if (!this.elementRef) {
                if (this.changes == null) {
                    this.changes = changes;
                }
                else {
                    try {
                        for (var _c = __values(Object.keys(changes)), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var property = _d.value;
                            this.changes[property] = changes[property];
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            else {
                if (this.changes == null) {
                    this.svyOnChanges(changes);
                }
                else {
                    try {
                        for (var _e = __values(Object.keys(changes)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var property = _f.value;
                            this.changes[property] = changes[property];
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    this.svyOnChanges(this.changes);
                    this.changes = null;
                }
            }
        };
        ServoyBaseComponent.prototype.ngOnDestroy = function () {
            this.servoyApi.unRegisterComponent(this);
        };
        // our init event that is called when dom is ready
        ServoyBaseComponent.prototype.svyOnInit = function () {
            this.addAttributes();
            this.componentContributor.componentCreated(this);
            this.viewStateListeners.forEach(function (listener) { return listener.afterViewInit(); });
        };
        // our change event that is called when dom is ready
        ServoyBaseComponent.prototype.svyOnChanges = function (_changes) {
        };
        ServoyBaseComponent.prototype.detectChanges = function () {
            this.cdRef.detectChanges();
        };
        /**
         * this should return the main native element (like the first div)
         */
        ServoyBaseComponent.prototype.getNativeElement = function () {
            return this.elementRef ? this.elementRef.nativeElement : null;
        };
        /**
         * sub classes can return a different native child then the default main element.
         * used currently only for horizontal aligment
         */
        ServoyBaseComponent.prototype.getNativeChild = function () {
            return this.elementRef.nativeElement;
        };
        ServoyBaseComponent.prototype.getRenderer = function () {
            return this.renderer;
        };
        ServoyBaseComponent.prototype.getWidth = function () {
            return this.getNativeElement().parentNode.parentNode.offsetWidth;
        };
        ServoyBaseComponent.prototype.getHeight = function () {
            return this.getNativeElement().parentNode.parentNode.offsetHeight;
        };
        ServoyBaseComponent.prototype.getLocationX = function () {
            return this.getNativeElement().parentNode.parentNode.offsetLeft;
        };
        ServoyBaseComponent.prototype.getLocationY = function () {
            return this.getNativeElement().parentNode.parentNode.offsetTop;
        };
        ServoyBaseComponent.prototype.addViewStateListener = function (listener) {
            this.viewStateListeners.add(listener);
        };
        ServoyBaseComponent.prototype.removeViewStateListener = function (listener) {
            this.viewStateListeners.delete(listener);
        };
        ServoyBaseComponent.prototype.initializeComponent = function () {
            if (!this.initialized && this.elementRef) {
                this.initialized = true;
                this.svyOnInit();
            }
        };
        ServoyBaseComponent.prototype.addAttributes = function () {
            var e_3, _a;
            if (!this.servoyAttributes)
                return;
            try {
                for (var _b = __values(Object.keys(this.servoyAttributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    this.renderer.setAttribute(this.getNativeElement(), key, this.servoyAttributes[key]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        return ServoyBaseComponent;
    }());
    ServoyBaseComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyBaseComponent, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ServoyBaseComponent.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: ServoyBaseComponent, inputs: { name: "name", servoyApi: "servoyApi", servoyAttributes: "servoyAttributes" }, viewQueries: [{ propertyName: "elementRef", first: true, predicate: ["element"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyBaseComponent, decorators: [{
                type: i0.Directive
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { name: [{
                    type: i0.Input
                }], servoyApi: [{
                    type: i0.Input
                }], servoyAttributes: [{
                    type: i0.Input
                }], elementRef: [{
                    type: i0.ViewChild,
                    args: ['element', { static: false }]
                }] } });
    var ComponentContributor = /** @class */ (function () {
        function ComponentContributor() {
        }
        ComponentContributor.prototype.componentCreated = function (component) {
            ComponentContributor.listeners.forEach(function (listener) { return listener.componentCreated(component); });
        };
        ComponentContributor.prototype.addComponentListener = function (listener) {
            ComponentContributor.listeners.add(listener);
        };
        return ComponentContributor;
    }());
    ComponentContributor.listeners = new Set();
    ComponentContributor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ComponentContributor, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ComponentContributor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ComponentContributor });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ComponentContributor, decorators: [{
                type: i0.Injectable
            }] });

    var Deferred = /** @class */ (function () {
        function Deferred() {
            var _this = this;
            this.promise = new Promise(function (resolve, reject) {
                _this._reject = reject;
                _this._resolve = resolve;
            });
        }
        Deferred.prototype.reject = function (reason) {
            this._reject(reason);
        };
        Deferred.prototype.resolve = function (value) {
            this._resolve(value);
        };
        return Deferred;
    }());

    var JSEvent = /** @class */ (function () {
        function JSEvent() {
        }
        return JSEvent;
    }());

    function getWindow() {
        return window;
    }
    var WindowRefService = /** @class */ (function () {
        function WindowRefService() {
        }
        Object.defineProperty(WindowRefService.prototype, "nativeWindow", {
            get: function () {
                return getWindow();
            },
            enumerable: false,
            configurable: true
        });
        return WindowRefService;
    }());
    WindowRefService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: WindowRefService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    WindowRefService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: WindowRefService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: WindowRefService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }] });

    // log levels for when debugEnabled(true) is called - if that is false, these levels are irrelevant
    // any custom debug levels can be used as well - these are just stored here so that custom code can test the level and see if it should log its message
    exports.LogLevel = void 0;
    (function (LogLevel) {
        LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
        LogLevel[LogLevel["WARN"] = 2] = "WARN";
        LogLevel[LogLevel["INFO"] = 3] = "INFO";
        LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
        LogLevel[LogLevel["SPAM"] = 5] = "SPAM";
    })(exports.LogLevel || (exports.LogLevel = {}));
    var LogConfiguration = /** @class */ (function () {
        function LogConfiguration(isDebugMode, level) {
            if (isDebugMode === void 0) { isDebugMode = false; }
            if (level === void 0) { level = exports.LogLevel.WARN; }
            this.isDebugMode = isDebugMode;
            this.level = level;
        }
        return LogConfiguration;
    }());
    var noop = function () { return undefined; };
    var LoggerService = /** @class */ (function () {
        function LoggerService(windowRefService, svyLogConfiguration, className) {
            this.svyLogConfiguration = svyLogConfiguration;
            this.className = className;
            this.enabled = false;
            this.console = windowRefService.nativeWindow.console;
        }
        LoggerService.prototype.buildMessage = function (message) {
            if (this.enabled) {
                return message instanceof Function ? message() : message;
            }
        };
        Object.defineProperty(LoggerService.prototype, "spam", {
            get: function () {
                if (this.svyLogConfiguration.level >= exports.LogLevel.SPAM) {
                    this.enabled = true;
                    return this.console.debug.bind(this.console, this.getTime() + ' SPAM ' + this.className + ' - ');
                }
                this.enabled = false;
                return noop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LoggerService.prototype, "debug", {
            get: function () {
                if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= exports.LogLevel.DEBUG) {
                    this.enabled = true;
                    return this.console.debug.bind(this.console, this.getTime() + ' DEBUG ' + this.className + ' - ');
                }
                this.enabled = false;
                return noop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LoggerService.prototype, "info", {
            get: function () {
                if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= exports.LogLevel.INFO) {
                    this.enabled = true;
                    return this.console.info.bind(this.console, this.getTime() + ' INFO ' + this.className + ' - ');
                }
                this.enabled = false;
                return noop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LoggerService.prototype, "warn", {
            get: function () {
                if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= exports.LogLevel.WARN) {
                    this.enabled = true;
                    return this.console.warn.bind(this.console, this.getTime() + ' WARN ' + this.className + ' - ');
                }
                this.enabled = false;
                return noop;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LoggerService.prototype, "error", {
            get: function () {
                if (this.svyLogConfiguration.isDebugMode || this.svyLogConfiguration.level >= exports.LogLevel.ERROR) {
                    this.enabled = true;
                    return this.console.error.bind(this.console, this.getTime() + ' ERROR ' + this.className + ' - ');
                }
                this.enabled = false;
                return noop;
            },
            enumerable: false,
            configurable: true
        });
        LoggerService.prototype.toggleDebugMode = function () {
            return this.svyLogConfiguration.isDebugMode = !this.svyLogConfiguration.isDebugMode;
        };
        Object.defineProperty(LoggerService.prototype, "logLevel", {
            get: function () {
                return this.svyLogConfiguration.level;
            },
            set: function (level) {
                this.svyLogConfiguration.level = level;
            },
            enumerable: false,
            configurable: true
        });
        LoggerService.prototype.getTime = function () {
            var time = new Date();
            return time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds();
        };
        return LoggerService;
    }());
    var LoggerFactory = /** @class */ (function () {
        function LoggerFactory(windowRefService) {
            this.windowRefService = windowRefService;
            this.instances = {};
            windowRefService.nativeWindow.logFactory = this;
            this.defaultLogConfiguration = windowRefService.nativeWindow.svyLogConfiguration;
            if (this.defaultLogConfiguration == null) {
                this.defaultLogConfiguration = new LogConfiguration();
                windowRefService.nativeWindow.svyLogConfiguration = this.defaultLogConfiguration;
                windowRefService.nativeWindow.logLevels = { error: exports.LogLevel.ERROR, debug: exports.LogLevel.DEBUG, info: exports.LogLevel.INFO, warn: exports.LogLevel.WARN, spam: exports.LogLevel.SPAM };
            }
        }
        LoggerFactory.prototype.getLogger = function (cls) {
            if (this.instances[cls] === undefined) {
                this.instances[cls] = new LoggerService(this.windowRefService, new LogConfiguration(this.defaultLogConfiguration.isDebugMode, this.defaultLogConfiguration.level), cls);
            }
            return this.instances[cls];
        };
        return LoggerFactory;
    }());
    LoggerFactory.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: LoggerFactory, deps: [{ token: WindowRefService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoggerFactory.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: LoggerFactory, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: LoggerFactory, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }], ctorParameters: function () { return [{ type: WindowRefService }]; } });

    var ServoyApi = /** @class */ (function () {
        function ServoyApi() {
        }
        return ServoyApi;
    }());

    var TooltipService = /** @class */ (function () {
        function TooltipService(_doc, windowRefService) {
            var _this = this;
            this.windowRefService = windowRefService;
            this.tipmousemove = function (e) {
                if (e.pageX || e.pageY) {
                    _this.tipmousemouveEventIsPage = true;
                    _this.tipmousemouveEventX = e.pageX;
                    _this.tipmousemouveEventY = e.pageY;
                }
                else if (e.clientX || e.clientY) {
                    _this.tipmousemouveEventIsPage = false;
                    _this.tipmousemouveEventX = e.clientX;
                    _this.tipmousemouveEventY = e.clientY;
                }
            };
            this.isTooltipActive = new rxjs.Subject();
            this.doc = _doc;
        }
        TooltipService.prototype.showTooltip = function (event, message, initialDelay, dismissDelay) {
            var _this = this;
            var e = event;
            if (!e)
                e = this.windowRefService.nativeWindow.event;
            var targ;
            if (e.target)
                targ = e.target;
            else if (e.srcElement)
                targ = e.srcElement;
            if (targ.nodeType === 3) // defeat Safari bug
                targ = targ.parentNode;
            if (targ.tagName && targ.tagName.toLowerCase() === 'option') { // stop tooltip if over option element
                this.hideTooltip();
                return;
            }
            var tDiv = this.getTooltipDiv();
            tDiv.innerHTML = message;
            tDiv.style.zIndex = '1600';
            tDiv.style.width = '';
            tDiv.style.overflow = 'hidden';
            this.tipmousemove(e);
            if (this.doc.addEventListener) {
                this.doc.addEventListener('mousemove', this.tipmousemove, false);
            }
            this.tipInitialTimeout = setTimeout(function () { return _this.adjustAndShowTooltip(dismissDelay); }, initialDelay);
        };
        TooltipService.prototype.hideTooltip = function () {
            this.internalHideTooltip();
        };
        TooltipService.prototype.getTooltipDiv = function () {
            if (!this.tooltipDiv) {
                this.tooltipDiv = this.doc.createElement('div');
                this.tooltipDiv.id = 'mktipmsg';
                this.tooltipDiv.className = 'mktipmsg tooltip-inner'; // tooltip-inner class is also used by ui-bootstrap-tpls-0.10.0
                this.doc.getElementsByTagName('body')[0].appendChild(this.tooltipDiv);
            }
            return this.tooltipDiv;
        };
        TooltipService.prototype.adjustAndShowTooltip = function (dismissDelay) {
            var _this = this;
            var x = 0;
            var y = 0;
            if (this.tipmousemouveEventX || this.tipmousemouveEventY) {
                if (this.tipmousemouveEventIsPage) {
                    x = this.tipmousemouveEventX;
                    y = this.tipmousemouveEventY;
                }
                else {
                    x = this.tipmousemouveEventX + this.doc.body.scrollLeft + this.doc.documentElement.scrollLeft;
                    y = this.tipmousemouveEventY + this.doc.body.scrollTop + this.doc.documentElement.scrollTop;
                }
            }
            var wWidth = 0;
            var wHeight = 0;
            if (typeof (this.windowRefService.nativeWindow.innerWidth) == 'number') {
                //Non-IE
                wWidth = this.windowRefService.nativeWindow.innerWidth;
                wHeight = this.windowRefService.nativeWindow.innerHeight;
            }
            else if (this.doc.documentElement && (this.doc.documentElement.clientWidth || this.doc.documentElement.clientHeight)) {
                //IE 6+ in 'standards compliant mode'
                wWidth = this.doc.documentElement.clientWidth;
                wHeight = this.doc.documentElement.clientHeight;
            }
            var tDiv = this.getTooltipDiv();
            tDiv.style.left = x + 10 + 'px';
            tDiv.style.top = y + 10 + 'px';
            tDiv.style.display = 'block';
            var tooltipOffsetWidth = x + 10 + tDiv.offsetWidth;
            if (wWidth < tooltipOffsetWidth) {
                var newLeft = x - 10 - tDiv.offsetWidth;
                if (newLeft < 0) {
                    newLeft = 0;
                    tDiv.style.width = x - 10 + 'px';
                }
                if (newLeft === 0)
                    newLeft = tDiv.offsetWidth;
                tDiv.style.left = newLeft + 'px';
            }
            var tooltipOffsetHeight = y + 10 + tDiv.offsetHeight;
            if (wHeight < tooltipOffsetHeight) {
                var newTop = y - 10 - tDiv.offsetHeight;
                tDiv.style.top = newTop + 'px';
            }
            this.isTooltipActive.next(true);
            this.tipTimeout = setTimeout(function () { return _this.hideTooltip(); }, dismissDelay);
        };
        TooltipService.prototype.internalHideTooltip = function () {
            if (this.doc.removeEventListener)
                this.doc.removeEventListener('mousemove', this.tipmousemove, false);
            clearTimeout(this.tipInitialTimeout);
            clearTimeout(this.tipTimeout);
            var tDiv = this.getTooltipDiv();
            tDiv.style.display = 'none';
            this.isTooltipActive.next(false);
        };
        return TooltipService;
    }());
    TooltipService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TooltipService, deps: [{ token: common.DOCUMENT }, { token: WindowRefService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TooltipService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TooltipService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TooltipService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: WindowRefService }];
        } });

    var TooltipDirective = /** @class */ (function () {
        function TooltipDirective(tooltipService) {
            var _this = this;
            this.tooltipService = tooltipService;
            this.isActive = false;
            this.tooltipService.isTooltipActive.subscribe(function (a) {
                _this.isActive = a;
            });
        }
        TooltipDirective.prototype.onMouseEnter = function (event) {
            if (this.tooltipText)
                this.tooltipService.showTooltip(event, this.tooltipText, 750, 5000);
        };
        TooltipDirective.prototype.onMouseLeave = function () {
            this.tooltipService.hideTooltip();
        };
        TooltipDirective.prototype.onClick = function () {
            this.tooltipService.hideTooltip();
        };
        TooltipDirective.prototype.onContextMenu = function () {
            this.tooltipService.hideTooltip();
        };
        TooltipDirective.prototype.ngOnDestroy = function () {
            this.tooltipService.hideTooltip();
        };
        return TooltipDirective;
    }());
    TooltipDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TooltipDirective, deps: [{ token: TooltipService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    TooltipDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: TooltipDirective, selector: "[svyTooltip]", inputs: { tooltipText: ["svyTooltip", "tooltipText"] }, host: { listeners: { "mouseenter": "onMouseEnter()", "mouseleave": "onMouseLeave()", "click": "onClick()", "contextmenu": "onContextMenu()" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TooltipDirective, decorators: [{
                type: i0.Directive,
                args: [{ selector: '[svyTooltip]' }]
            }], ctorParameters: function () { return [{ type: TooltipService }]; }, propDecorators: { tooltipText: [{
                    type: i0.Input,
                    args: ['svyTooltip']
                }], onMouseEnter: [{
                    type: i0.HostListener,
                    args: ['mouseenter']
                }], onMouseLeave: [{
                    type: i0.HostListener,
                    args: ['mouseleave']
                }], onClick: [{
                    type: i0.HostListener,
                    args: ['click']
                }], onContextMenu: [{
                    type: i0.HostListener,
                    args: ['contextmenu']
                }] } });

    var ServoyPublicService = /** @class */ (function () {
        function ServoyPublicService() {
        }
        return ServoyPublicService;
    }());
    ServoyPublicService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ServoyPublicService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicService, decorators: [{
                type: i0.Injectable
            }] });

    var DecimalkeyconverterDirective = /** @class */ (function () {
        function DecimalkeyconverterDirective(el, servoyService) {
            this.el = el;
            this.servoyService = servoyService;
            this.element = el.nativeElement;
        }
        DecimalkeyconverterDirective.prototype.onKeypress = function (e) {
            if (e.which === 110 && this.svyFormat && this.svyFormat.type === 'NUMBER') {
                var caretPos = this.element.selectionStart;
                var startString = this.element.value.slice(0, caretPos);
                var endString = this.element.value.slice(this.element.selectionEnd, this.element.value.length);
                this.element.value = (startString + common.getLocaleNumberSymbol(this.servoyService.getLocale(), common.NumberSymbol.Decimal) + endString);
                this.element.focus();
                this.element.setSelectionRange(caretPos + 1, caretPos + 1);
                if (e.preventDefault)
                    e.preventDefault();
            }
        };
        return DecimalkeyconverterDirective;
    }());
    DecimalkeyconverterDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: DecimalkeyconverterDirective, deps: [{ token: i0__namespace.ElementRef }, { token: ServoyPublicService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    DecimalkeyconverterDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: DecimalkeyconverterDirective, selector: "[svyDecimalKeyConverter]", inputs: { svyFormat: ["svyDecimalKeyConverter", "svyFormat"] }, host: { listeners: { "keydown": "onKeypress($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: DecimalkeyconverterDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[svyDecimalKeyConverter]'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: ServoyPublicService }]; }, propDecorators: { svyFormat: [{
                    type: i0.Input,
                    args: ['svyDecimalKeyConverter']
                }], onKeypress: [{
                    type: i0.HostListener,
                    args: ['keydown', ['$event']]
                }] } });

    var MnemonicletterFilterPipe = /** @class */ (function () {
        function MnemonicletterFilterPipe() {
        }
        MnemonicletterFilterPipe.prototype.transform = function (input, letter) {
            if (letter && input)
                return input.replace(letter, '<u>' + letter + '</u>');
            return input;
        };
        return MnemonicletterFilterPipe;
    }());
    MnemonicletterFilterPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: MnemonicletterFilterPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    MnemonicletterFilterPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: MnemonicletterFilterPipe, name: "mnemonicletterFilter" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: MnemonicletterFilterPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'mnemonicletterFilter' }]
            }] });
    var NotNullOrEmptyPipe = /** @class */ (function () {
        function NotNullOrEmptyPipe() {
        }
        NotNullOrEmptyPipe.prototype.transform = function (value, _args) {
            if (value)
                return value.filter(function (a) { return a && (a.realValue || a.displayValue); });
            return value;
        };
        return NotNullOrEmptyPipe;
    }());
    NotNullOrEmptyPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NotNullOrEmptyPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    NotNullOrEmptyPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NotNullOrEmptyPipe, name: "notNullOrEmpty" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: NotNullOrEmptyPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'notNullOrEmpty' }]
            }] });
    var HtmlFilterPipe = /** @class */ (function () {
        function HtmlFilterPipe() {
        }
        HtmlFilterPipe.prototype.transform = function (input) {
            if (input && input.indexOf && input.indexOf('<body') >= 0 && input.lastIndexOf('</body') >= 0) {
                input = input.substring(input.indexOf('<body') + 6, input.lastIndexOf('</body'));
            }
            return input;
        };
        return HtmlFilterPipe;
    }());
    HtmlFilterPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: HtmlFilterPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    HtmlFilterPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: HtmlFilterPipe, name: "htmlFilter" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: HtmlFilterPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'htmlFilter' }]
            }] });
    var TrustAsHtmlPipe = /** @class */ (function () {
        function TrustAsHtmlPipe(domSanitizer) {
            this.domSanitizer = domSanitizer;
        }
        TrustAsHtmlPipe.prototype.transform = function (input, trustAsHtml) {
            if (trustAsHtml) {
                return this.domSanitizer.bypassSecurityTrustHtml(input);
            }
            return input;
        };
        return TrustAsHtmlPipe;
    }());
    TrustAsHtmlPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TrustAsHtmlPipe, deps: [{ token: i1__namespace.DomSanitizer }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    TrustAsHtmlPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TrustAsHtmlPipe, name: "trustAsHtml" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: TrustAsHtmlPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'trustAsHtml' }]
            }], ctorParameters: function () { return [{ type: i1__namespace.DomSanitizer }]; } });

    var MILLSIGN = '\u2030';
    var Format = /** @class */ (function () {
        function Format() {
            this.display = null;
            this.uppercase = false;
            this.lowercase = false;
            this.type = null;
            this.isMask = false;
            this.isRaw = false;
            this.isNumberValidator = false;
            this.edit = null;
            this.placeHolder = '';
            this.percent = '';
            this.allowedCharacters = '';
            this.maxLength = 0;
        }
        return Format;
    }());
    var FormattingService = /** @class */ (function () {
        function FormattingService(servoyService) {
            this.servoyService = servoyService;
        }
        // formatting stufff
        FormattingService.prototype.format = function (data, format, useEditFormat) {
            var formatString = useEditFormat ? format.edit : format.display;
            if ((!format) || (!format.type) || ((typeof data === 'number') && isNaN(data))) {
                if (!format && ((format.type === 'NUMBER') || (format.type === 'INTEGER')) && (typeof data === 'number') && !isNaN(data)) {
                    // make sure is always returned with correct type, otherwise compare will not work well
                    return data.toString();
                }
                return data;
            }
            if (data === undefined || data === null)
                return '';
            if ((format.type === 'NUMBER') || (format.type === 'INTEGER')) {
                return this.formatNumbers(data, formatString);
            }
            else if (format.type === 'TEXT') {
                var formattedValue = this.formatText(data, formatString);
                if (format.uppercase)
                    formattedValue = formattedValue.toUpperCase();
                else if (format.lowercase)
                    formattedValue = formattedValue.toLowerCase();
                return formattedValue;
            }
            else if (format.type === 'DATETIME') {
                return this.formatDate(data, formatString);
            }
            return data;
        };
        FormattingService.prototype.testKeyPressed = function (event, keyCode) {
            var code;
            if (!event)
                event = window.event;
            if (!event)
                return false;
            if (event.keyCode)
                code = event.keyCode;
            else if (event.which)
                code = event.which;
            return code === keyCode;
        };
        // test numbers only
        FormattingService.prototype.testForNumbersOnly = function (e, keyChar, vElement, vFindMode, vCheckNumbers, vSvyFormat, skipMaxLength) {
            if (!vFindMode && vCheckNumbers) {
                if (this.testKeyPressed(e, 13) && e.target.tagName.toUpperCase() === 'INPUT') {
                    //do not looses focus, just apply the format and push value
                    vElement.dispatchEvent(new CustomEvent('change', { bubbles: true, detail: { text: function () { return vElement.value; } } }));
                }
                else if (vSvyFormat.type === 'INTEGER') {
                    var currentLanguageNumeralSymbols = numbro__default['default'].languageData();
                    if (keyChar === undefined || keyChar === null) {
                        return this.numbersonly(e, false, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency
                            .symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                    }
                    else {
                        return this.numbersonlyForChar(keyChar, false, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency.symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                    }
                }
                else if (vSvyFormat.type === 'NUMBER' || ((vSvyFormat.type === 'TEXT') && vSvyFormat.isNumberValidator)) {
                    var currentLanguageNumeralSymbols = numbro__default['default'].languageData();
                    if (keyChar === undefined || keyChar === null) {
                        return this.numbersonly(e, true, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency.symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                    }
                    else {
                        return this.numbersonlyForChar(keyChar, true, currentLanguageNumeralSymbols.delimiters.decimal, currentLanguageNumeralSymbols.delimiters.thousands, currentLanguageNumeralSymbols.currency.symbol, vSvyFormat.percent, vElement, skipMaxLength === true ? 0 : vSvyFormat.maxLength);
                    }
                }
            }
            return true;
        };
        // unformatting stuff
        FormattingService.prototype.unformat = function (data, servoyFormat, type, currentValue) {
            if ((!servoyFormat) || (!type) || (!data && data !== 0))
                return data;
            if ((type === 'NUMBER') || (type === 'INTEGER')) {
                return this.unformatNumbers(data, servoyFormat);
            }
            else if (type === 'TEXT') {
                return data;
            }
            else if (type === 'DATETIME') {
                if ('' === data)
                    return null;
                servoyFormat = this.convertFormat(servoyFormat);
                var d = luxon.DateTime.fromFormat(data, servoyFormat, { locale: this.servoyService.getLocale() }).toJSDate();
                // if format has not year/month/day use the one from the current model value
                // because luxon will just use current date
                if (currentValue && !isNaN(currentValue.getTime())) {
                    if (servoyFormat.indexOf('y') === -1) {
                        d.setFullYear(currentValue.getFullYear());
                    }
                    if (servoyFormat.indexOf('W') === -1 && servoyFormat.indexOf('o') === -1) {
                        if (servoyFormat.indexOf('M') === -1) {
                            d.setMonth(currentValue.getMonth());
                        }
                        if (servoyFormat.indexOf('d') === -1) {
                            d.setDate(currentValue.getDate());
                        }
                    }
                }
                return d;
            }
            return data;
        };
        FormattingService.prototype.unformatNumbers = function (data, format) {
            if (data === '')
                return data;
            //treat scientiffic numbers
            if (data.toString().toLowerCase().indexOf('e') > -1 && !isNaN(data)) {
                return new Number(data).valueOf();
            }
            var multFactor = 1;
            var MILLSIGN = '\u2030';
            if (format.indexOf(MILLSIGN) > -1 && format.indexOf('\'' + MILLSIGN + '\'') == -1) {
                multFactor *= 0.001;
            }
            if (format.indexOf('\'') > -1) {
                // replace the literals
                var parts = format.split('\'');
                for (var i = 0; i < parts.length; i++) {
                    if (i % 2 === 1) {
                        data = data.replace(new RegExp(parts[i], 'g'), '');
                    }
                }
            }
            var ret = numbro__default['default'](data).value();
            ret *= multFactor;
            return ret;
        };
        FormattingService.prototype.numbersonly = function (e, decimal, decimalChar, groupingChar, currencyChar, percentChar, vElement, mlength) {
            var key;
            if (window.event) {
                key = window.event['keyCode'];
            }
            else if (e) {
                key = e.which;
            }
            else {
                return true;
            }
            if ((key == null) || (key === 0) || (key === 8) || (key === 9) || (key === 13) || (key === 27) || (e.ctrlKey && key === 97) || (e.ctrlKey && key === 99) ||
                (e.ctrlKey && key === 118) || (e.ctrlKey && key === 120)) { //added CTRL-A, X, C and V
                return true;
            }
            var keychar = String.fromCharCode(key);
            return this.numbersonlyForChar(keychar, decimal, decimalChar, groupingChar, currencyChar, percentChar, vElement, mlength);
        };
        FormattingService.prototype.numbersonlyForChar = function (keychar, decimal, decimalChar, groupingChar, currencyChar, percentChar, vElement, mlength) {
            var value = vElement.value;
            if (mlength > 0 && value) {
                var counter = 0;
                if (('0123456789').indexOf(keychar) !== -1)
                    counter++;
                var stringLength = value.length;
                for (var i = 0; i < stringLength; i++) {
                    if (('0123456789').indexOf(value.charAt(i)) !== -1)
                        counter++;
                }
                var selectedTxt = this.getSelectedText(vElement);
                if (selectedTxt) {
                    // selection will get deleted/replaced by typed key
                    for (var i = 0; i < selectedTxt.length; i++) {
                        if (('0123456789').indexOf(selectedTxt.charAt(i)) !== -1)
                            counter--;
                    }
                }
                if (counter > mlength)
                    return false;
            }
            if ((('-0123456789').indexOf(keychar) > -1)) {
                return true;
            }
            else if (decimal && (keychar === decimalChar)) {
                return true;
            }
            else if (keychar === groupingChar) {
                return true;
            }
            else if (keychar === currencyChar) {
                return true;
            }
            else if (keychar === percentChar) {
                return true;
            }
            return false;
        };
        FormattingService.prototype.getSelectedText = function (textarea) {
            var sel = null;
            if (textarea) {
                var start = textarea['selectionStart'];
                var end = textarea['selectionEnd'];
                sel = textarea['value'].substring(start, end);
            }
            return sel;
        };
        FormattingService.prototype.formatNumbers = function (data, servoyFormat) {
            if (!servoyFormat)
                return data;
            if (data === '')
                return data;
            data = Number(data); // just to make sure that if it was a string representing a number we turn it into a number
            if (typeof data === 'number' && isNaN(data))
                return ''; // cannot format something that is not a number
            var initialData = data;
            var patchedFormat = servoyFormat; // patched format for numeraljs format
            var i;
            var j;
            var prefix = '';
            var sufix = '';
            if (patchedFormat.indexOf(';') > 0) {
                if (data < 0) {
                    patchedFormat = patchedFormat.split(';')[1];
                }
                else
                    patchedFormat = patchedFormat.split(';')[0];
            }
            if (data < 0)
                data *= -1;
            if (patchedFormat.indexOf('\u00A4') >= 0) {
                patchedFormat = patchedFormat.replace(new RegExp('\u00A4', 'g'), numbro__default['default'].languageData().currency.symbol);
            }
            if (servoyFormat.indexOf('-') >= 0 && initialData >= 0 && servoyFormat.indexOf(';') < 0) {
                patchedFormat = patchedFormat.replace(new RegExp('-', 'g'), '');
            }
            if (patchedFormat.indexOf('%') > -1 && patchedFormat.indexOf('\'%\'') === -1) {
                data *= 100;
            }
            else if (patchedFormat.indexOf(MILLSIGN) > -1 && patchedFormat.indexOf('\'' + MILLSIGN + '\'') === -1) {
                data *= 1000;
            }
            var numberStart = patchedFormat.length;
            var index = patchedFormat.indexOf('0');
            if (index >= 0) {
                numberStart = index;
            }
            index = patchedFormat.indexOf('#');
            if (index >= 0 && index < numberStart) {
                numberStart = index;
            }
            var numberEnd = 0;
            index = patchedFormat.lastIndexOf('0');
            if (index >= 0) {
                numberEnd = index;
            }
            index = patchedFormat.lastIndexOf('#');
            if (index >= 0 && index > numberEnd) {
                numberEnd = index;
            }
            if (numberStart > 0) {
                prefix = patchedFormat.substring(0, numberStart);
            }
            if (numberEnd < patchedFormat.length - 1) {
                sufix = patchedFormat.substring(numberEnd + 1);
            }
            patchedFormat = patchedFormat.substring(numberStart, numberEnd + 1);
            var ret;
            prefix = prefix.replace(new RegExp('\'', 'g'), '');
            sufix = sufix.replace(new RegExp('\'', 'g'), '');
            if (servoyFormat.indexOf('-') === -1 && initialData < 0 && servoyFormat.indexOf(';') < 0) {
                prefix = prefix + '-';
            }
            // scientific notation case
            if (servoyFormat.indexOf('E') > -1) {
                var frmt = /([0#.,]+)+E0+.*/.exec(patchedFormat)[1];
                var integerDigits = 0;
                var fractionalDigits = 0;
                var countIntegerState = true;
                for (i = 0; i < frmt.length; i++) {
                    var chr = frmt[i];
                    if (chr === '.') {
                        countIntegerState = false;
                        continue;
                    }
                    if (chr === ',')
                        continue;
                    if (countIntegerState) {
                        integerDigits++;
                    }
                    else {
                        fractionalDigits++;
                    }
                }
                ret = Number(data).toExponential(integerDigits + fractionalDigits);
            }
            else {
                // get min digits
                var minLen = 0;
                var optionalDigits = 0;
                for (i = 0; i < patchedFormat.length; i++) {
                    if (patchedFormat[i] === '0') {
                        minLen++;
                    }
                    else if (patchedFormat[i] === '#' && minLen === 0) {
                        optionalDigits++;
                    }
                    else if (patchedFormat[i] === '.') {
                        break;
                    }
                }
                patchedFormat = patchedFormat.replace(new RegExp('(#+)', 'g'), '[$1]');
                patchedFormat = patchedFormat.replace(new RegExp('#', 'g'), '0');
                ret = numbro__default['default'](data).format(patchedFormat);
                // set min digits
                if (minLen > 0) {
                    var retSplit = ret.split(numbro__default['default'].languageData().delimiters.decimal);
                    for (i = 0; i < retSplit[0].length; i++) {
                        if (retSplit[0][i] < '0' || retSplit[0][i] > '9')
                            continue;
                        for (j = i; j < retSplit[0].length; j++) {
                            if (retSplit[0][j] >= '0' && retSplit[0][j] <= '9')
                                continue;
                            break;
                        }
                        var nrMissing0 = minLen - (j - i);
                        if (nrMissing0 > 0) {
                            ret = retSplit[0].substring(0, i);
                            for (j = 0; j < nrMissing0; j++)
                                ret += '0';
                            ret += retSplit[0].substring(i);
                            if (retSplit.length > 1)
                                ret += (numbro__default['default'].languageData().delimiters.decimal + retSplit[1]);
                        }
                        break;
                    }
                }
                // fix the optional digits
                if (patchedFormat.indexOf(',') === -1 && optionalDigits > 0) {
                    var toEliminate = 0;
                    for (i = 0; i < ret.length; i++) {
                        if (ret.charAt(i) === '0') {
                            toEliminate++;
                        }
                        else {
                            break;
                        }
                    }
                    if (toEliminate > 0) {
                        if (toEliminate > optionalDigits) {
                            toEliminate = optionalDigits;
                        }
                        ret = ret.substring(toEliminate);
                        if (ret.indexOf(numbro__default['default'].languageData().delimiters.decimal) === 0) {
                            // we eliminated too much
                            ret = '0' + ret;
                        }
                    }
                }
            }
            return prefix + ret + sufix;
        };
        FormattingService.prototype.formatText = function (data, servoyFormat) {
            if (!servoyFormat)
                return data;
            var error = 'input string not corresponding to format : ' + data + ' , ' + servoyFormat;
            var ret = '';
            var isEscaping = false;
            var offset = 0;
            if (data && typeof data === 'number') {
                data = data.toString();
            }
            for (var i = 0; i < servoyFormat.length; i++) {
                var formatChar = servoyFormat[i];
                var dataChar = data[i - offset];
                if (dataChar === undefined)
                    break;
                if (isEscaping && formatChar !== '\'') {
                    if (dataChar !== formatChar)
                        throw error;
                    ret += dataChar;
                    continue;
                }
                switch (formatChar) {
                    case '\'':
                        isEscaping = !isEscaping;
                        offset++;
                        break;
                    case 'U':
                        if (dataChar.match(/[a-zA-Z\u00C0-\u00ff]/) == null)
                            throw error;
                        ret += dataChar.toUpperCase();
                        break;
                    case 'L':
                        if (dataChar.match(/[a-zA-Z\u00C0-\u00ff]/) == null)
                            throw error;
                        ret += dataChar.toLowerCase();
                        break;
                    case 'A':
                        if (dataChar.match(/[0-9a-zA-Z\u00C0-\u00ff]/) == null)
                            throw error;
                        ret += dataChar;
                        break;
                    case '?':
                        if (dataChar.match(/[a-zA-Z\u00C0-\u00ff]/) == null)
                            throw error;
                        ret += dataChar;
                        break;
                    case '*':
                        ret += dataChar;
                        break;
                    case 'H':
                        if (dataChar.match(/[0-9a-fA-F]/) == null)
                            throw error;
                        ret += dataChar.toUpperCase();
                        break;
                    case '#':
                        if (dataChar.match(/[\d]/) == null)
                            throw error;
                        ret += dataChar;
                        break;
                    default:
                        ret += formatChar;
                        if (formatChar !== dataChar)
                            offset++;
                        break;
                }
            }
            return ret;
        };
        FormattingService.prototype.formatDate = function (data, dateFormat) {
            if (!(data instanceof Date))
                return data;
            dateFormat = this.convertFormat(dateFormat);
            var formatted = luxon.DateTime.fromJSDate(data).setLocale(this.servoyService.getLocale()).toFormat(dateFormat);
            return formatted.trim ? formatted.trim() : formatted;
        };
        FormattingService.prototype.convertFormat = function (dateFormat) {
            if (!dateFormat)
                dateFormat = 'F'; // long date format of luxon
            // adjust to luxon js formatting (from java simple date format)
            dateFormat = dateFormat.replace(new RegExp('Y', 'g'), 'y');
            dateFormat = dateFormat.replace(new RegExp('aa', 'g'), 'a');
            dateFormat = dateFormat.replace(new RegExp('E', 'g'), 'EEE');
            dateFormat = dateFormat.replace(new RegExp('u', 'g'), 'E');
            dateFormat = dateFormat.replace(new RegExp('w', 'g'), 'W');
            // no equivalent for K, just put h for now
            dateFormat = dateFormat.replace(new RegExp('K', 'g'), 'h');
            dateFormat = dateFormat.replace(new RegExp('k', 'g'), 'H');
            dateFormat = dateFormat.replace(new RegExp('D', 'g'), 'o');
            // if week is found then the year must be 'k' for luxon (iso week year)
            if (dateFormat.indexOf('W') !== -1) {
                dateFormat = dateFormat.replace(new RegExp('y', 'g'), 'k');
            }
            return dateFormat;
        };
        return FormattingService;
    }());
    FormattingService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormattingService, deps: [{ token: ServoyPublicService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FormattingService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormattingService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormattingService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: ServoyPublicService }]; } });

    var FormatFilterPipe = /** @class */ (function () {
        function FormatFilterPipe(formatService) {
            this.formatService = formatService;
        }
        FormatFilterPipe.prototype.transform = function (input, format) {
            if (!format)
                return input;
            return this.formatService.format(input, format, !format.display);
        };
        return FormatFilterPipe;
    }());
    FormatFilterPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormatFilterPipe, deps: [{ token: FormattingService }], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    FormatFilterPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormatFilterPipe, name: "formatFilter" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormatFilterPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'formatFilter' }]
            }], ctorParameters: function () { return [{ type: FormattingService }]; } });

    var EmptyValueFilterPipe = /** @class */ (function () {
        function EmptyValueFilterPipe() {
        }
        EmptyValueFilterPipe.prototype.transform = function (input) {
            // eslint-disable-next-line eqeqeq
            if (input == '')
                return '\u00A0';
            return input;
        };
        return EmptyValueFilterPipe;
    }());
    EmptyValueFilterPipe.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: EmptyValueFilterPipe, deps: [], target: i0__namespace.ɵɵFactoryTarget.Pipe });
    EmptyValueFilterPipe.ɵpipe = i0__namespace.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: EmptyValueFilterPipe, name: "emptyValue" });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: EmptyValueFilterPipe, decorators: [{
                type: i0.Pipe,
                args: [{ name: 'emptyValue' }]
            }] });

    var StartEditDirective = /** @class */ (function () {
        function StartEditDirective(logFactory) {
            this.log = logFactory.getLogger('StartEditDirective');
        }
        StartEditDirective.prototype.onFocus = function (e) {
            if (!this.hostComponent) {
                this.log.error('host component not found for the start edit directive use [hostComponent]="self" besides this in the template (component must be extending ServoyBaseComponent)');
            }
            else if (this.hostComponent.servoyApi && this.dataProviderID !== undefined) {
                this.hostComponent.servoyApi.startEdit(this.dataProviderID);
            }
            else {
                this.log.error('Can\'t call startEdit, missing servoyApi and dataProviderID for field ' + this.hostComponent);
            }
        };
        return StartEditDirective;
    }());
    StartEditDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: StartEditDirective, deps: [{ token: LoggerFactory }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    StartEditDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: StartEditDirective, selector: "[svyStartEdit]", inputs: { dataProviderID: ["svyStartEdit", "dataProviderID"], hostComponent: "hostComponent" }, host: { listeners: { "focus": "onFocus($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: StartEditDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[svyStartEdit]'
                    }]
            }], ctorParameters: function () { return [{ type: LoggerFactory }]; }, propDecorators: { dataProviderID: [{
                    type: i0.Input,
                    args: ['svyStartEdit']
                }], hostComponent: [{
                    type: i0.Input
                }], onFocus: [{
                    type: i0.HostListener,
                    args: ['focus', ['$event']]
                }] } });

    var ImageMediaIdDirective = /** @class */ (function () {
        function ImageMediaIdDirective(_elemRef, _renderer) {
            this._elemRef = _elemRef;
            this._renderer = _renderer;
            this.clearStyle = new Map();
            this.clearStyle.set('width', '0px');
            this.clearStyle.set('height', '0px');
            this.clearStyle.set('backgroundImage', '');
        }
        ImageMediaIdDirective.prototype.ngOnChanges = function (changes) {
            if (changes['hostComponent']) {
                this.hostComponent.addViewStateListener(this);
            }
        };
        ImageMediaIdDirective.prototype.ngOnDestroy = function () {
            if (this.hostComponent) {
                this.hostComponent.removeViewStateListener(this);
            }
        };
        ImageMediaIdDirective.prototype.afterViewInit = function () {
            var _this = this;
            var nativeElement = this.hostComponent.getNativeElement();
            var renderer = this.hostComponent.getRenderer();
            renderer.listen(nativeElement, 'mouseenter', function (e) {
                if (_this.rollOverImgStyle) {
                    _this.setCSSStyle(_this.rollOverImgStyle);
                }
            });
            renderer.listen(nativeElement, 'mouseleave', function (e) {
                if (_this.rollOverImgStyle) {
                    if (_this.imgStyle) {
                        _this.setCSSStyle(_this.imgStyle);
                    }
                    else {
                        _this.setCSSStyle(_this.clearStyle);
                    }
                }
            });
            this.setImageStyle();
        };
        ImageMediaIdDirective.prototype.setImageStyle = function () {
            var _this = this;
            if (this.media && (this.media.img || this.media.rollOverImg) || this.rollOverImgStyle || this.imgStyle) {
                var componentSize = {
                    width: this._elemRef.nativeElement.parentNode.parentNode.clientWidth,
                    height: this._elemRef.nativeElement.parentNode.parentNode.clientHeight
                };
                if (componentSize.height === 0 || componentSize.width === 0)
                    setTimeout(function () { return _this.setImageStyle(); }, 100);
                else {
                    var mediaOptions = this.media.mediaOptions;
                    if (this.media.rollOverImg) {
                        this.rollOverImgStyle = this.parseImageOptions(this.media.rollOverImg, mediaOptions, componentSize);
                    }
                    else {
                        this.rollOverImgStyle = null;
                    }
                    if (this.media.img) {
                        this.imgStyle = this.parseImageOptions(this.media.img, mediaOptions, componentSize);
                        this.setCSSStyle(this.imgStyle);
                    }
                    else {
                        this.imgStyle = null;
                        this.setCSSStyle(this.clearStyle);
                    }
                }
            }
        };
        ImageMediaIdDirective.prototype.parseImageOptions = function (image, mediaOptions, componentSize) {
            var bgstyle = new Map();
            bgstyle.set('background-image', 'url(\'' + image + '\')');
            bgstyle.set('background-repeat', 'no-repeat');
            bgstyle.set('background-position', 'left');
            bgstyle.set('display', 'inline-block');
            bgstyle.set('vertical-align', 'middle');
            if (mediaOptions === undefined)
                mediaOptions = 14; // reduce-enlarge & keep aspect ration
            var mediaKeepAspectRatio = mediaOptions === 0 || ((mediaOptions & 8) === 8);
            // default  img size values
            var imgWidth = 16;
            var imgHeight = 16;
            if (image.indexOf('imageWidth=') > 0 && image.indexOf('imageHeight=') > 0) {
                var vars_1 = {};
                image.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
                    vars_1[key] = value;
                });
                imgWidth = vars_1['imageWidth'];
                imgHeight = vars_1['imageHeight'];
            }
            var widthChange = imgWidth / componentSize.width;
            var heightChange = imgHeight / componentSize.height;
            if (widthChange > 1.01 || heightChange > 1.01 || widthChange < 0.99 || heightChange < 0.99) {
                if ((mediaOptions & 6) === 6) {
                    if (mediaKeepAspectRatio) {
                        if (widthChange > heightChange) {
                            imgWidth = imgWidth / widthChange;
                            imgHeight = imgHeight / widthChange;
                        }
                        else {
                            imgWidth = imgWidth / heightChange;
                            imgHeight = imgHeight / heightChange;
                        }
                    }
                    else {
                        imgWidth = componentSize.width;
                        imgHeight = componentSize.height;
                    }
                }
                else if ((mediaOptions & 2) == 2) {
                    if (widthChange > 1.01 && heightChange > 1.01) {
                        if (mediaKeepAspectRatio) {
                            if (widthChange > heightChange) {
                                imgWidth = imgWidth / widthChange;
                                imgHeight = imgHeight / widthChange;
                            }
                            else {
                                imgWidth = imgWidth / heightChange;
                                imgHeight = imgHeight / heightChange;
                            }
                        }
                        else {
                            imgWidth = componentSize.width;
                            imgHeight = componentSize.height;
                        }
                    }
                    else if (widthChange > 1.01) {
                        imgWidth = imgWidth / widthChange;
                        if (mediaKeepAspectRatio) {
                            imgHeight = imgHeight / widthChange;
                        }
                        else {
                            imgHeight = componentSize.height;
                        }
                    }
                    else if (heightChange > 1.01) {
                        imgHeight = imgHeight / heightChange;
                        if (mediaKeepAspectRatio) {
                            imgWidth = imgWidth / heightChange;
                        }
                        else {
                            imgWidth = componentSize.width;
                        }
                    }
                }
                else if ((mediaOptions & 4) == 4) {
                    if (widthChange < 0.99 && heightChange < 0.99) {
                        if (mediaKeepAspectRatio) {
                            if (widthChange > heightChange) {
                                imgWidth = imgWidth / widthChange;
                                imgHeight = imgHeight / widthChange;
                            }
                            else {
                                imgWidth = imgWidth / heightChange;
                                imgHeight = imgHeight / heightChange;
                            }
                        }
                        else {
                            imgWidth = componentSize.width;
                            imgHeight = componentSize.height;
                        }
                    }
                    else if (widthChange < 0.99) {
                        imgWidth = imgWidth / widthChange;
                        if (mediaKeepAspectRatio) {
                            imgHeight = imgHeight / widthChange;
                        }
                        else {
                            imgHeight = componentSize.height;
                        }
                    }
                    else if (heightChange < 0.99) {
                        imgHeight = imgHeight / heightChange;
                        if (mediaKeepAspectRatio) {
                            imgWidth = imgWidth / heightChange;
                        }
                        else {
                            imgWidth = componentSize.width;
                        }
                    }
                }
            }
            bgstyle.set('background-size', mediaKeepAspectRatio ? 'contain' : '100% 100%');
            bgstyle.set('width', Math.round(imgWidth) + 'px');
            bgstyle.set('height', Math.round(imgHeight) + 'px');
            return bgstyle;
        };
        ImageMediaIdDirective.prototype.setCSSStyle = function (cssStyle) {
            var _this = this;
            cssStyle.forEach(function (value, key) {
                _this._renderer.setStyle(_this._elemRef.nativeElement, key, value);
            });
        };
        return ImageMediaIdDirective;
    }());
    ImageMediaIdDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ImageMediaIdDirective, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    ImageMediaIdDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: ImageMediaIdDirective, selector: "[svyImageMediaId]", inputs: { media: ["svyImageMediaId", "media"], hostComponent: "hostComponent" }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ImageMediaIdDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[svyImageMediaId]'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { media: [{
                    type: i0.Input,
                    args: ['svyImageMediaId']
                }], hostComponent: [{
                    type: i0.Input
                }] } });

    var AutosaveDirective = /** @class */ (function () {
        function AutosaveDirective(servoyService, elementRef) {
            this.servoyService = servoyService;
            this.elementRef = elementRef;
        }
        AutosaveDirective.prototype.onClick = function (target) {
            if (target == this.elementRef.nativeElement || target.parentNode == this.elementRef.nativeElement) {
                this.servoyService.callService('applicationServerService', 'autosave', {}, true);
            }
        };
        return AutosaveDirective;
    }());
    AutosaveDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: AutosaveDirective, deps: [{ token: ServoyPublicService }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AutosaveDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: AutosaveDirective, selector: "[svyAutosave]", host: { listeners: { "click": "onClick($event.target)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: AutosaveDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[svyAutosave]'
                    }]
            }], ctorParameters: function () { return [{ type: ServoyPublicService }, { type: i0__namespace.ElementRef }]; }, propDecorators: { onClick: [{
                    type: i0.HostListener,
                    args: ['click', ['$event.target']]
                }] } });

    var UploadDirective = /** @class */ (function () {
        function UploadDirective(servoyService) {
            this.servoyService = servoyService;
            this.propertyName = 'dataProviderID';
        }
        UploadDirective.prototype.click = function (e) {
            this.servoyService.showFileOpenDialog('Please select a file', false, null, this.url);
        };
        UploadDirective.prototype.ngOnInit = function () {
            this.url = this.servoyService.generateUploadUrl(this.formname, this.componentName, this.propertyName);
        };
        return UploadDirective;
    }());
    UploadDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: UploadDirective, deps: [{ token: ServoyPublicService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    UploadDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: UploadDirective, selector: "[svyUpload]", inputs: { formname: "formname", componentName: "componentName" }, host: { listeners: { "click": "click()" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: UploadDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[svyUpload]'
                    }]
            }], ctorParameters: function () { return [{ type: ServoyPublicService }]; }, propDecorators: { formname: [{
                    type: i0.Input
                }], componentName: [{
                    type: i0.Input
                }], click: [{
                    type: i0.HostListener,
                    args: ['click']
                }] } });

    var MASK_CONST = {
        // Predefined character definitions
        definitions: {
            '#': '[0-9]',
            0: '[0-9]',
            U: '[A-Z]',
            L: '[a-z]',
            A: '[A-Za-z0-9]',
            '?': '[A-Za-z]',
            '*': '.',
            H: '[A-F0-9]'
        },
        converters: {
            U: function (c) {
                return c.toUpperCase();
            },
            L: function (c) {
                return c.toLowerCase();
            },
            H: function (c) {
                return c.toUpperCase();
            }
        }
    };
    exports.MaskFormat = /** @class */ (function () {
        function MaskFormat(format, _renderer, element, formatService, doc) {
            var _this = this;
            this.format = format;
            this._renderer = _renderer;
            this.element = element;
            this.formatService = formatService;
            this.doc = doc;
            this.firstNonMaskPos = -1;
            this.buffer = [];
            this.tests = [];
            this.converters = [];
            this.ignore = false;
            this.settings = {};
            this.settings['placeholder'] = this.format.placeHolder ? this.format.placeHolder : ' ';
            if (this.format.allowedCharacters)
                this.settings['allowedCharacters'] = this.format.allowedCharacters;
            if (!this.settings['completed']) {
                this.settings['completed'] = null;
            }
            this.mask = this.format.edit;
            //          if (!this.mask && this.element.value.length > 0) { //TODO check condition
            //              return this.buffer.map(function(c, i) { //TODO why return??
            //                  return this.tests[i] ? c : null;
            //              }, this).join('');
            //          }
            var skipNextMask = false;
            this.filteredMask = '';
            var defs = MASK_CONST.definitions;
            var converts = MASK_CONST.converters;
            this.converters = [];
            var partialPosition = this.mask.length;
            var len = this.mask.length;
            var chars = this.mask.split('');
            for (var i = 0; i < chars.length; i++) {
                var c = chars[i];
                //            if (c == '?') {
                //                len--;
                //                partialPosition = i;
                //            } else
                if (!skipNextMask && c === '\'') {
                    skipNextMask = true;
                    len--;
                    partialPosition--;
                }
                else {
                    if (!skipNextMask && defs[c]) {
                        if (c === '*' && this.settings['allowedCharacters']) {
                            this.tests.push(new RegExp('[' + this.settings['allowedCharacters'] + ']'));
                        }
                        else {
                            this.tests.push(new RegExp(defs[c]));
                        }
                        if (this.firstNonMaskPos === -1)
                            this.firstNonMaskPos = this.tests.length - 1;
                    }
                    else {
                        this.tests.push(null);
                        skipNextMask = false;
                    }
                    this.converters.push(converts[c]);
                    this.filteredMask += c;
                }
            }
            this.buffer = this.filteredMask.split('').map(function (c, i, array) {
                return this.tests[i] ? this.getPlaceHolder(i) : c;
            }, this);
            this._renderer.listen(this.element, 'input', function () {
                _this.setCaret(_this.checkVal(true));
            });
            this._renderer.listen(this.element, 'focus', function () { return _this.onFocus(); });
            this._renderer.listen(this.element, 'blur', function () { return _this.onBlur(); });
            this._renderer.listen(this.element, 'keypress', function (event) { return _this.onKeypress(event); });
            this._renderer.listen(this.element, 'keydown', function (event) { return _this.onKeydown(event); });
        }
        MaskFormat.prototype.onFocus = function () {
            var _this = this;
            this.focusText = this.element.value;
            var pos = this.checkVal(true);
            this.writeBuffer();
            setTimeout(function () { return _this.setCaretOnFocus(pos); }, 0);
        };
        MaskFormat.prototype.setCaretOnFocus = function (pos) {
            if (pos !== this.filteredMask.length) {
                this.setCaret(pos);
            }
            else {
                this.setCaret(this.element.selectionStart);
            }
        };
        MaskFormat.prototype.onBlur = function () {
            var _this = this;
            this.checkVal(true);
            if (this.element.value !== this.focusText) {
                this.element.dispatchEvent(new CustomEvent('change', { bubbles: true, detail: { text: function () { return _this.element.value; } } }));
            }
        };
        MaskFormat.prototype.onKeypress = function (e) {
            var _this = this;
            if (this.formatService.testKeyPressed(e, 13) && e.target.tagName.toUpperCase() === 'INPUT') {
                //do not looses focus, just apply the format and push value
                this.element.dispatchEvent(new CustomEvent('change', { bubbles: true, detail: { text: function () { return _this.element.value; } } }));
                return true;
            }
            if (this.ignore) {
                this.ignore = false;
                // Fixes Mac FF bug on backspace
                return (e.keyCode === 8) ? false : null;
            }
            // TODO needed? e = e || window.event;
            var k = e.charCode || e.keyCode || e.which;
            var posBegin = this.element.selectionStart;
            var posEnd = this.element.selectionEnd;
            if (e.ctrlKey || e.altKey || e.metaKey) { // Ignore
                return true;
            }
            else if ((k >= 32 && k <= 125) || k > 186) { // typeable characters
                var p = this.seekNext(posBegin - 1);
                if (p < this.mask.length) {
                    var c = String.fromCharCode(k);
                    if (this.converters[p]) {
                        c = this.converters[p](c);
                    }
                    if (this.tests[p].test(c)) {
                        //                    shiftR(p);
                        this.buffer[p] = c;
                        this.writeBuffer();
                        var next = this.seekNext(p);
                        this.setCaret(next);
                        if (this.settings['completed'] && next == this.mask.length)
                            this.settings['completed'].call(this.element);
                    }
                }
            }
            return false;
        };
        MaskFormat.prototype.onKeydown = function (e) {
            var iPhone = (window.orientation !== undefined);
            var posBegin = this.element.selectionStart;
            var posEnd = this.element.selectionEnd;
            var k = e.keyCode;
            this.ignore = (k < 16 || (k > 16 && k < 32) || (k > 32 && k < 41));
            if (k === 37) {
                var nextValidChar = this.seekPrevious(posBegin);
                if (nextValidChar !== posBegin) {
                    this.setCaret(nextValidChar);
                    return false;
                }
                return;
            }
            else if (k === 39) {
                var nextValidChar = this.seekNext(posBegin);
                if (nextValidChar !== posBegin) {
                    this.setCaret(nextValidChar);
                    return false;
                }
                return;
            }
            else {
                var nextValidChar = this.seekNext(posBegin - 1) - posBegin;
                if (nextValidChar > 0) {
                    posBegin += nextValidChar;
                    posEnd += nextValidChar;
                }
            }
            // backspace, delete, and escape get special treatment
            if (k === 8 || k === 46 || (iPhone && k === 127)) {
                if (posBegin === posEnd) {
                    this.clear(posBegin + (k === 46 ? 0 : -1), (k === 46 ? 1 : 0));
                }
                else {
                    this.clearBuffer(posBegin, posEnd);
                    this.writeBuffer();
                    this.setCaret(Math.max(this.firstNonMaskPos, posBegin));
                }
                return false;
            }
            else if (k === 27) { // escape
                this.element.value = this.focusText;
                this.setCaret(0, this.checkVal());
                return false;
            }
            else if (posBegin !== posEnd && !this.ignore) {
                this.clearBuffer(posBegin, posEnd);
            }
        };
        MaskFormat.prototype.setCaret = function (begin, end) {
            if (this.element.value.length === 0)
                return;
            if (typeof begin === 'number') {
                end = (typeof end === 'number') ? end : begin;
                if (this.element != null) {
                    if (this.element['createTextRange']) {
                        var range = this.element['createTextRange']();
                        range.move('character', begin);
                        range.select();
                    }
                    else if (this.element.selectionStart >= 0) {
                        this.element.setSelectionRange(begin, end);
                    }
                }
            }
            else {
                if (this.element['setSelectionRange']) {
                    begin = this.element.selectionStart;
                    end = this.element.selectionEnd;
                }
                else if (this.doc.getSelection() && this.doc.getSelection()['createRange']) {
                    var range = this.doc.getSelection()['createRange']();
                    begin = 0 - range.duplicate().moveStart('character', -100000);
                    end = begin + range.text.length;
                }
                return { begin: begin, end: end };
            }
        };
        MaskFormat.prototype.seekPrevious = function (pos) {
            while (--pos >= 0 && !this.tests[pos])
                ;
            return pos;
        };
        MaskFormat.prototype.seekNext = function (pos) {
            while (++pos <= this.mask.length && !this.tests[pos])
                ;
            return pos;
        };
        MaskFormat.prototype.clear = function (pos, caretAddition) {
            while (!this.tests[pos] && --pos >= 0)
                ;
            if (this.tests[pos]) {
                this.buffer[pos] = this.getPlaceHolder(pos);
            }
            this.writeBuffer();
            if (caretAddition !== 0) {
                var nextPos = pos + caretAddition;
                while (nextPos >= 0 && nextPos < this.mask.length) {
                    if (this.tests[nextPos]) {
                        pos = nextPos;
                        break;
                    }
                    nextPos = nextPos + caretAddition;
                }
            }
            this.setCaret(Math.max(this.firstNonMaskPos, pos));
        };
        MaskFormat.prototype.clearBuffer = function (start, end) {
            for (var i = start; i < end && i < this.mask.length; i++) {
                if (this.tests[i])
                    this.buffer[i] = this.getPlaceHolder(i);
            }
        };
        MaskFormat.prototype.writeBuffer = function () {
            this.element.value = this.buffer.join('');
            return this.element.value;
        };
        MaskFormat.prototype.checkVal = function (allow) {
            if (allow === void 0) { allow = false; }
            // try to place characters where they belong
            var partialPosition = this.mask.length;
            var test = this.element.value;
            var lastMatch = -1;
            var firstError = -1;
            for (var i = 0, pos = 0; i < this.mask.length; i++) {
                if (this.tests[i]) {
                    this.buffer[i] = this.getPlaceHolder(i);
                    while (pos++ < test.length) {
                        var c = test.charAt(pos - 1);
                        // if the char is the place holder then dont shift..
                        if (c === this.buffer[i]) {
                            if (firstError === -1)
                                firstError = i;
                            break;
                        }
                        if (this.tests[i].test(c)) {
                            this.buffer[i] = c;
                            lastMatch = i;
                            break;
                        }
                    }
                    if (pos > test.length)
                        break;
                }
                else if (this.buffer[i] === test.charAt(pos) && i !== partialPosition) {
                    pos++;
                    //                    lastMatch = i;
                }
            }
            if (!allow && lastMatch + 1 < partialPosition) {
                this.element.value = '';
                this.clearBuffer(0, this.mask.length);
            }
            else if (allow && lastMatch === -1) {
                this.element.value = '';
                this.clearBuffer(0, this.mask.length);
            }
            else if (allow || lastMatch + 1 >= partialPosition) {
                this.writeBuffer();
                if (!allow)
                    this.element.value = this.element.value.substring(0, lastMatch + 1);
            }
            return firstError !== -1 ? firstError : (partialPosition ? lastMatch : this.firstNonMaskPos);
        };
        MaskFormat.prototype.getPlaceHolder = function (i) {
            return this.settings['placeholder'].length > 1 ? this.settings['placeholder'].charAt(i) : this.settings['placeholder'];
        };
        return MaskFormat;
    }());
    exports.MaskFormat = __decorate([
        __param(4, i0.Inject(common.DOCUMENT))
    ], exports.MaskFormat);

    var NumberParser = /** @class */ (function () {
        function NumberParser() {
            var locale = new Intl.NumberFormat().resolvedOptions().locale;
            var parts = new Intl.NumberFormat(locale).formatToParts(12345.6);
            var numerals = __spreadArray([], __read(new Intl.NumberFormat(locale, { useGrouping: false }).format(9876543210))).reverse();
            var index = new Map(numerals.map(function (d, i) { return [d, i]; }));
            this._group = new RegExp("[" + parts.find(function (d) { return d.type === 'group'; }).value + "]", 'g');
            this._decimal = new RegExp("[" + parts.find(function (d) { return d.type === 'decimal'; }).value + "]");
            this._numeral = new RegExp("[" + numerals.join('') + "]", 'g');
            this._index = function (d) { return index.get(d).toString(); };
        }
        NumberParser.prototype.parse = function (str) {
            return (str.trim().replace(this._group, '').replace(this._decimal, '.').replace(this._numeral, this._index)) ? +str : NaN;
        };
        return NumberParser;
    }());
    var FormatDirective = /** @class */ (function () {
        function FormatDirective(_renderer, _elementRef, formatService, doc, logFactory) {
            this._renderer = _renderer;
            this._elementRef = _elementRef;
            this.formatService = formatService;
            this.doc = doc;
            this.hasFocus = false;
            this.realValue = null;
            this.isKeyPressEventFired = false;
            this.oldInputValue = null;
            this.listeners = [];
            this.onChangeCallback = function (_) { };
            this.onTouchedCallback = function () { };
            this.log = logFactory.getLogger('formatdirective');
        }
        FormatDirective.prototype.touched = function () {
            this.onTouchedCallback();
            this.hasFocus = false;
            if (this.format.display && this.format.edit && this.format.edit !== this.format.display) {
                this.writeValue(this.realValue);
            }
        };
        FormatDirective.prototype.focussed = function () {
            this.hasFocus = true;
            if (this.format.display && this.format.edit && this.format.edit !== this.format.display) {
                this.writeValue(this.realValue);
            }
        };
        FormatDirective.prototype.input = function (value) {
            var data = value;
            var inputType = this.getType();
            if (inputType === 'datetime-local') {
                data = this.formatService.unformat(value, FormatDirective.DATETIMEFORMAT.display, FormatDirective.DATETIMEFORMAT.type, this.realValue);
            }
            else if (inputType === 'date') {
                data = this.formatService.unformat(value, FormatDirective.DATEFORMAT.display, FormatDirective.DATEFORMAT.type, this.realValue);
            }
            else if (inputType === 'time') {
                data = this.formatService.unformat(value, FormatDirective.TIMEFORMAT.display, FormatDirective.TIMEFORMAT.type, this.realValue);
            }
            else if (inputType === 'month') {
                data = this.formatService.unformat(value, FormatDirective.MONTHFORMAT.display, FormatDirective.MONTHFORMAT.type, this.realValue);
            }
            else if (inputType === 'week') {
                data = this.formatService.unformat(value, FormatDirective.WEEKFORMAT.display, FormatDirective.WEEKFORMAT.type, this.realValue);
            }
            else if (inputType === 'number') {
                data = FormatDirective.BROWSERNUMBERFORMAT.parse(value);
            }
            else if (inputType === 'email') {
                data = value;
            }
            else if (!this.findmode && this.format) {
                var type = this.format.type;
                var format = this.format.display ? this.format.display : this.format.edit;
                if (this.hasFocus && this.format.edit && !this.format.isMask)
                    format = this.format.edit;
                try {
                    data = this.formatService.unformat(data, format, type, this.realValue);
                }
                catch (e) {
                    this.log.error(e);
                    //TODO set error state
                }
                if (this.format.type === 'TEXT' && this.format.isRaw && this.format.isMask) {
                    if (data && format && data.length === format.length) {
                        var ret = '';
                        for (var i = 0; i < format.length; i++) {
                            switch (format[i]) {
                                case 'U':
                                case 'L':
                                case 'A':
                                case '?':
                                case '*':
                                case 'H':
                                case '#':
                                    ret += data[i];
                                    break;
                                default:
                                    // ignore literal characters
                                    break;
                            }
                        }
                        data = ret;
                    }
                }
            }
            this.realValue = data;
            this.onChangeCallback(data);
        };
        FormatDirective.prototype.ngAfterViewInit = function () {
            this.setFormat();
        };
        FormatDirective.prototype.ngOnChanges = function () {
            this.setFormat();
        };
        FormatDirective.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        FormatDirective.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        FormatDirective.prototype.writeValue = function (value) {
            this.realValue = value;
            var inputType = this.getType();
            if (inputType === 'datetime-local') {
                var data = this.formatService.format(value, FormatDirective.DATETIMEFORMAT, false);
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else if (inputType === 'date') {
                var data = this.formatService.format(value, FormatDirective.DATEFORMAT, false);
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else if (inputType === 'time') {
                var data = this.formatService.format(value, FormatDirective.TIMEFORMAT, false);
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else if (inputType === 'month') {
                var data = this.formatService.format(value, FormatDirective.MONTHFORMAT, false);
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else if (inputType === 'week') {
                var data = this.formatService.format(value, FormatDirective.WEEKFORMAT, false);
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else if (inputType === 'number') {
                var data = value ? new Intl.NumberFormat().format(value) : '';
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else if (inputType === 'email') {
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);
            }
            else if (value && this.format) {
                var data = value;
                if (!this.findmode) {
                    data = inputType === 'number' && data.toString().length >= this.format.maxLength ? data.toString().substring(0, this.format.maxLength) : data;
                    var useEdit = !this.format.display;
                    if (this.format.edit && !this.format.isMask && this.hasFocus)
                        useEdit = true;
                    try {
                        data = this.formatService.format(data, this.format, useEdit);
                    }
                    catch (e) {
                        this.log.error(e);
                    }
                    if (data && this.format.type === 'TEXT') {
                        if (this.format.uppercase)
                            data = data.toUpperCase();
                        else if (this.format.lowercase)
                            data = data.toLowerCase();
                    }
                }
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', data);
            }
            else {
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', value ? value : '');
            }
        };
        FormatDirective.prototype.getType = function () {
            var type = this._elementRef.nativeElement.type;
            return type ? type.toLocaleLowerCase() : 'text';
        };
        FormatDirective.prototype.setFormat = function () {
            var _this = this;
            this.listeners.forEach(function (lFn) { return lFn(); });
            this.listeners = [];
            if (this.format) {
                if (!this.findmode && (this.format.uppercase || this.format.lowercase)) {
                    this.listeners.push(this._renderer.listen(this._elementRef.nativeElement, 'input', function () { return _this.upperOrLowerCase(); }));
                }
                if (this.format.isNumberValidator || this.format.type === 'NUMBER' || this.format.type === 'INTEGER') {
                    this.listeners.push(this._renderer.listen(this._elementRef.nativeElement, 'keypress', function (event) {
                        _this.isKeyPressEventFired = true;
                        return _this.formatService.testForNumbersOnly(event, null, _this._elementRef.nativeElement, _this.findmode, true, _this.format, false);
                    }));
                    this.listeners.push(this._renderer.listen(this._elementRef.nativeElement, 'input', function (event) { return _this.inputFiredForNumbersCheck(event); }));
                }
                if (this.format.maxLength) {
                    if (!this.findmode) {
                        this._renderer.setAttribute(this._elementRef.nativeElement, 'maxlength', this.format.maxLength + '');
                    }
                    else {
                        this._renderer.removeAttribute(this._elementRef.nativeElement, 'maxlength');
                    }
                }
                if (!this.findmode && this.format.isMask) {
                    new exports.MaskFormat(this.format, this._renderer, this._elementRef.nativeElement, this.formatService, this.doc);
                }
                this.writeValue(this.realValue);
            }
        };
        // lower and upper case handling
        FormatDirective.prototype.upperOrLowerCase = function () {
            var element = this._elementRef.nativeElement;
            var caretPos = element.selectionStart;
            element.value = this.format.uppercase ? element.value.toUpperCase() : element.value.toLowerCase();
            element.setSelectionRange(caretPos, caretPos);
        };
        FormatDirective.prototype.inputFiredForNumbersCheck = function (event) {
            var currentValue = this._elementRef.nativeElement.value;
            if (!this.isKeyPressEventFired && event.target.tagName.toUpperCase() === 'INPUT') {
                // get inserted chars
                var inserted = this.findDelta(currentValue, this.oldInputValue);
                // get removed chars
                var removed = this.findDelta(this.oldInputValue, currentValue);
                // determine if user pasted content
                var pasted = inserted.length > 1 || (!inserted && !removed);
                if (!pasted && !removed) {
                    if (!this.formatService.testForNumbersOnly(event, inserted, this._elementRef.nativeElement, this.findmode, true, this.format, true)) {
                        currentValue = this.oldInputValue;
                    }
                }
                //If number validator, check all chars in string and extract only the valid chars.
                if (event.target.type.toUpperCase() === 'NUMBER' || this.format.type === 'NUMBER' || this.format.type === 'INTEGER' || this.format.isNumberValidator) {
                    currentValue = this.getNumbersFromString(event, currentValue, this.oldInputValue);
                }
                if (currentValue !== this._elementRef.nativeElement.value) {
                    this._elementRef.nativeElement.value = currentValue;
                    // // detect IE8 and above, and Edge; call on change manually because of https://bugs.jquery.com/ticket/10818
                    // if (/MSIE/.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge/.test(navigator.userAgent)) {
                    // 	var changeOnBlurForIE = function() {
                    // 		 element.change();
                    // 		 element.off("blur", callChangeOnBlur);
                    // 	 }
                    // 	 element.on("blur", changeOnBlurForIE);
                    // }
                }
                this.oldInputValue = currentValue;
                this.isKeyPressEventFired = false;
            }
            if (this.isKeyPressEventFired) {
                this.oldInputValue = currentValue;
                this.isKeyPressEventFired = false;
            }
        };
        FormatDirective.prototype.findDelta = function (value, prevValue) {
            var delta = '';
            if (typeof value === 'string' && typeof prevValue === 'string' && value.length >= prevValue.length) {
                for (var i = 0; i < value.length; i++) {
                    var str = value.substr(0, i) + value.substr(i + value.length - prevValue.length);
                    if (str === prevValue) {
                        delta = value.substr(i, value.length - prevValue.length);
                        break;
                    }
                }
            }
            return delta;
        };
        FormatDirective.prototype.getNumbersFromString = function (e, currentValue, oldInputValue) {
            if (oldInputValue === currentValue) {
                return currentValue;
            }
            var stripped = '';
            for (var i = 0; i < currentValue.length; i++) {
                if (this.formatService.testForNumbersOnly(e, currentValue.charAt(i), this._elementRef.nativeElement, this.findmode, true, this.format, true)) {
                    stripped = stripped + currentValue.charAt(i);
                    if (stripped.length === this.format.maxLength)
                        break;
                }
            }
            return stripped;
        };
        return FormatDirective;
    }());
    FormatDirective.DATETIMEFORMAT = { display: 'yyyy-MM-ddTHH:mm:ss', type: 'DATETIME' };
    FormatDirective.DATEFORMAT = { display: 'yyyy-MM-dd', type: 'DATETIME' };
    FormatDirective.MONTHFORMAT = { display: 'yyyy-MM', type: 'DATETIME' };
    FormatDirective.WEEKFORMAT = { display: 'YYYY-[W]WW', type: 'DATETIME' };
    FormatDirective.TIMEFORMAT = { display: 'HH:mm', type: 'DATETIME' };
    FormatDirective.BROWSERNUMBERFORMAT = new NumberParser();
    FormatDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormatDirective, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }, { token: FormattingService }, { token: common.DOCUMENT }, { token: LoggerFactory }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FormatDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: FormatDirective, selector: "[svyFormat]", inputs: { format: ["svyFormat", "format"], findmode: "findmode" }, host: { listeners: { "blur": "touched()", "focus": "focussed()", "change": "input($event.target.value)" } }, providers: [{
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: i0.forwardRef(function () { return FormatDirective; }),
                multi: true
            }], usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: FormatDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // eslint-disable-next-line @angular-eslint/directive-selector
                        selector: '[svyFormat]',
                        providers: [{
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: i0.forwardRef(function () { return FormatDirective; }),
                                multi: true
                            }]
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }, { type: FormattingService }, { type: Document, decorators: [{
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: LoggerFactory }];
        }, propDecorators: { format: [{
                    type: i0.Input,
                    args: ['svyFormat']
                }], findmode: [{
                    type: i0.Input
                }], touched: [{
                    type: i0.HostListener,
                    args: ['blur', []]
                }], focussed: [{
                    type: i0.HostListener,
                    args: ['focus', []]
                }], input: [{
                    type: i0.HostListener,
                    args: ['change', ['$event.target.value']]
                }] } });

    var SabloTabseq = /** @class */ (function () {
        function SabloTabseq(_elemRef, cdRef) {
            this._elemRef = _elemRef;
            this.cdRef = cdRef;
            this.designChildIndexToArrayPosition = {};
            this.designChildTabSeq = []; // contains ordered numbers that will be keys in 'runtimeChildIndexes'; can have duplicates
            this.runtimeChildIndexes = {}; // map designChildIndex[i] -> runtimeIndex for child or designChildIndex[i] -> [runtimeIndex1, runtimeIndex2] in case there are multiple equal design time indexes
        }
        // handle event: Child Servoy Tab Sequence registered
        SabloTabseq.prototype.registerChildHandler = function (designChildIndex, runtimeChildIndex, event) {
            if (this.designTabSeq === -2 || designChildIndex === -2) {
                this.recalculateIndexesHandler(designChildIndex ? designChildIndex : 0, false);
                event.stopPropagation();
                return false;
            }
            // insert it sorted
            var posInDesignArray = 0;
            for (var tz = 0; tz < this.designChildTabSeq.length && this.designChildTabSeq[tz] < designChildIndex; tz++) {
                posInDesignArray = tz + 1;
            }
            if (posInDesignArray === this.designChildTabSeq.length || this.designChildTabSeq[posInDesignArray] > designChildIndex) {
                this.designChildTabSeq.splice(posInDesignArray, 0, designChildIndex);
                // always keep in designChildIndexToArrayPosition[i] the first occurrance of design index i in the sorted designChildTabSeq array
                for (var tz = posInDesignArray; tz < this.designChildTabSeq.length; tz++) {
                    this.designChildIndexToArrayPosition[this.designChildTabSeq[tz]] = tz;
                }
                this.runtimeChildIndexes[designChildIndex] = runtimeChildIndex;
            }
            else {
                // its == that means that we have dupliate design indexes; we treat this special - all same design index children as a list in one runtime index array cell
                if (!this.runtimeChildIndexes[designChildIndex].push) {
                    this.runtimeChildIndexes[designChildIndex] = [this.runtimeChildIndexes[designChildIndex]];
                }
                this.runtimeChildIndexes[designChildIndex].push(runtimeChildIndex);
            }
            this.recalculateIndexesHandler(designChildIndex ? designChildIndex : 0, false);
            event.stopPropagation();
            return false;
        };
        SabloTabseq.prototype.unregisterChildHandler = function (designChildIndex, runtimeChildIndex, event) {
            if (this.designTabSeq === -2 || designChildIndex === -2) {
                event.stopPropagation();
                return false;
            }
            var posInDesignArray = this.designChildIndexToArrayPosition[designChildIndex];
            if (posInDesignArray !== undefined) {
                var keyInRuntimeArray = this.designChildTabSeq[posInDesignArray];
                var multipleEqualDesignValues = this.runtimeChildIndexes[keyInRuntimeArray].push;
                if (!multipleEqualDesignValues) {
                    delete this.designChildIndexToArrayPosition[designChildIndex];
                    for (var tmp in this.designChildIndexToArrayPosition) {
                        if (this.designChildIndexToArrayPosition[tmp] > posInDesignArray)
                            this.designChildIndexToArrayPosition[tmp]--;
                    }
                    this.designChildTabSeq.splice(posInDesignArray, 1);
                    delete this.runtimeChildIndexes[keyInRuntimeArray];
                }
                else {
                    this.runtimeChildIndexes[keyInRuntimeArray].splice(this.runtimeChildIndexes[keyInRuntimeArray].indexOf(runtimeChildIndex), 1);
                    if (this.runtimeChildIndexes[keyInRuntimeArray].length === 1)
                        this.runtimeChildIndexes[keyInRuntimeArray] = this.runtimeChildIndexes[keyInRuntimeArray][0];
                }
            }
            event.stopPropagation();
            return false;
        };
        // handle event: child tree was now linked or some child needs extra indexes; runtime indexes can be computed starting at the given child;
        // recalculate Parent Servoy Tab Sequence
        SabloTabseq.prototype.recalculateIndexesHandler = function (designChildIndex, initialRootRecalculate, event) {
            if (this.designTabSeq === -2 || designChildIndex === -2) {
                if (event)
                    event.stopPropagation();
                return false;
            }
            if (!this.initializing) {
                // a new child is ready/linked; recalculate tab indexes for it and after it
                var startIdx = (this.designChildIndexToArrayPosition && this.designChildIndexToArrayPosition[designChildIndex] !== undefined) ?
                    this.designChildIndexToArrayPosition[designChildIndex] : 0;
                this.recalculateChildRuntimeIndexesStartingAt(startIdx, false);
            }
            else if (initialRootRecalculate) {
                // this is $rootScope (one $parent extra cause the directive creates it); we always assume a sabloTabseq directive is bound to it;
                // now that it is linked we can do initial calculation of tre
                this.runtimeIndex.startIndex = this.runtimeIndex.nextAvailableIndex = 1;
                this.recalculateChildRuntimeIndexesStartingAt(0, true);
            } // else wait for parent tabSeq directives to get linked as well
            if (event)
                event.stopPropagation();
            return false;
        };
        SabloTabseq.prototype.disableTabseq = function (event) {
            this.isEnabled = false;
            this.recalculateChildRuntimeIndexesStartingAt(0, true);
            event.stopPropagation();
            return false;
        };
        SabloTabseq.prototype.enableTabseq = function (event) {
            this.isEnabled = true;
            this.trigger(this._elemRef.nativeElement.parentNode, 'recalculatePSTS', [0, false]);
            event.stopPropagation();
            return false;
        };
        SabloTabseq.prototype.ngOnInit = function () {
            // called by angular in parents first then in children
            if (!this.designTabSeq)
                this.designTabSeq = 0;
            this.initializing = true;
            this.isEnabled = true;
            // runtime index -1 == SKIP focus traversal in browser
            // runtime index  0 == DEFAULT == design tab seq 0 (not tabIndex attr set to element or it's children)
            this.runtimeIndex = { startIndex: -1, nextAvailableIndex: -1, sablotabseq: this };
            // -1 runtime initially for all (in case some node in the tree has -2 design (skip) and children have >= 0,
            // at runtime all children should be excluded as wel)
            this.updateCurrentDomElTabIndex();
            // check to see if this is the top-most tabSeq container
            if (this.config && this.config.root) {
                // it's root tab seq container (so no parent); just do initial tree calculation
                this.recalculateIndexesHandler(0, true);
            }
            else {
                if (this.designTabSeq !== -2) {
                    this.trigger(this._elemRef.nativeElement.parentNode, 'registerCSTS', [this.designTabSeq, this.runtimeIndex]);
                }
            }
        };
        SabloTabseq.prototype.ngOnChanges = function (changes) {
            var change = changes['designTabSeq'];
            if (change && !change.firstChange) {
                if (!(this.config && this.config.root)) {
                    if (change.previousValue !== -2)
                        this.trigger(this._elemRef.nativeElement.parentNode, 'unregisterCSTS', [change.previousValue, this.runtimeIndex]);
                    if (!this.designTabSeq)
                        this.designTabSeq = 0;
                    this.runtimeIndex.startIndex = -1;
                    this.runtimeIndex.nextAvailableIndex = -1;
                    this.initializing = true;
                    if (this.designTabSeq !== -2) {
                        this.trigger(this._elemRef.nativeElement.parentNode, 'registerCSTS', [this.designTabSeq, this.runtimeIndex]);
                        // here we could send [0] instead of [designTabSeq] - it would potentially calculate more but start again from first parent available index,
                        // not higher index (the end user behavior being the same)
                        this.trigger(this._elemRef.nativeElement.parentNode, 'recalculatePSTS', [this.designTabSeq]);
                    }
                    else {
                        this.updateCurrentDomElTabIndex(); // -1 runtime
                    }
                }
            }
        };
        SabloTabseq.prototype.recalculateChildRuntimeIndexesStartingAt = function (posInDesignArray /*inclusive*/, triggeredByParent) {
            if (this.designTabSeq === -2)
                return;
            if (!this.isEnabled || this.runtimeIndex.startIndex === -1) {
                this.runtimeIndex.nextAvailableIndex = this.runtimeIndex.startIndex;
                this.runtimeIndex.startIndex = -1;
            }
            else if (this.designTabSeq === 0) {
                // this element doesn't set any tabIndex attribute (default behavior)
                this.runtimeIndex.nextAvailableIndex = this.runtimeIndex.startIndex;
                this.runtimeIndex.startIndex = 0;
            }
            else if (this.runtimeIndex.startIndex === 0) {
                this.runtimeIndex.nextAvailableIndex = 0;
            }
            else if (this.runtimeIndex.nextAvailableIndex === -1) {
                var reservedGap = (this.config && this.config.reservedGap) ? this.config.reservedGap : 0;
                this.runtimeIndex.nextAvailableIndex = this.runtimeIndex.startIndex + reservedGap;
            }
            if (posInDesignArray === 0)
                this.updateCurrentDomElTabIndex();
            var recalculateStartIndex = this.runtimeIndex.startIndex;
            if (posInDesignArray > 0 && posInDesignArray - 1 < this.designChildTabSeq.length) {
                var runtimeCI = this.runtimeChildIndexes[this.designChildTabSeq[posInDesignArray - 1]]; // this can be an array in case of multiple equal design indexes being siblings
                recalculateStartIndex = runtimeCI.push ? runtimeCI[runtimeCI.length - 1].nextAvailableIndex : runtimeCI.nextAvailableIndex;
            }
            for (var i = posInDesignArray; i < this.designChildTabSeq.length; i++) {
                var childRuntimeIndex = this.runtimeChildIndexes[this.designChildTabSeq[i]];
                if (childRuntimeIndex.push) {
                    // multiple equal design time indexes as siblings
                    var max = recalculateStartIndex;
                    for (var k in childRuntimeIndex) {
                        if (childRuntimeIndex.hasOwnProperty(k)) {
                            childRuntimeIndex[k].startIndex = recalculateStartIndex;
                            // call recalculate on whole child; normally it only makes sense for same index siblings
                            // if they are not themselfes containers, just apply the given value
                            childRuntimeIndex[k].sablotabseq.recalculateChildRuntimeIndexesStartingAt(0, true);
                            if (max < childRuntimeIndex[k].nextAvailableIndex)
                                max = childRuntimeIndex[k].nextAvailableIndex;
                        }
                    }
                    recalculateStartIndex = max;
                }
                else {
                    childRuntimeIndex.startIndex = recalculateStartIndex;
                    childRuntimeIndex.sablotabseq.recalculateChildRuntimeIndexesStartingAt(0, true); // call recalculate on whole child
                    recalculateStartIndex = childRuntimeIndex.nextAvailableIndex;
                }
            }
            if (this.initializing)
                this.initializing = undefined; // it's now considered initialized as first runtime index caluculation is done
            var parentRecalculateNeeded;
            if (this.runtimeIndex.startIndex !== 0 && this.runtimeIndex.startIndex !== -1) {
                var ownTabIndexBump = this.hasOwnTabIndex() ? 1 : 0;
                parentRecalculateNeeded = (this.runtimeIndex.nextAvailableIndex < recalculateStartIndex + ownTabIndexBump);
                var reservedGap = (this.config && this.config.reservedGap) ? this.config.reservedGap : 0;
                if (parentRecalculateNeeded)
                    this.runtimeIndex.nextAvailableIndex = recalculateStartIndex + reservedGap + ownTabIndexBump;
            }
            else {
                // start index 0 means default (no tabIndex attr. set)
                parentRecalculateNeeded = false;
            }
            // if this container now needs more tab indexes than it was reserved; a recalculate on parent needs to be triggered in this case
            if (parentRecalculateNeeded && !triggeredByParent)
                this.trigger(this._elemRef.nativeElement.parentNode, 'recalculatePSTS', [this.designTabSeq, false]);
        };
        SabloTabseq.prototype.hasOwnTabIndex = function () {
            return (!this.config || !(this.config.container || this.config.root));
        };
        SabloTabseq.prototype.updateCurrentDomElTabIndex = function () {
            if (this.hasOwnTabIndex()) {
                if (this.runtimeIndex.startIndex !== 0) {
                    this.setDOMTabIndex(this.runtimeIndex.startIndex);
                }
                else {
                    this.setDOMTabIndex(undefined);
                }
            }
        };
        SabloTabseq.prototype.setDOMTabIndex = function (tabindex) {
            this.tabindex = tabindex;
            this.cdRef.detectChanges();
        };
        SabloTabseq.prototype.trigger = function (target, event, arg) {
            var customEvent = new CustomEvent(event, {
                bubbles: true,
                detail: arg
            });
            target.dispatchEvent(customEvent);
        };
        SabloTabseq.prototype.ngOnDestroy = function () {
            // unregister current tabSeq from parent tabSeq container
            if (this._elemRef.nativeElement.parentNode) {
                this.trigger(this._elemRef.nativeElement.parentNode, 'unregisterCSTS', [this.designTabSeq, this.runtimeIndex]);
            }
        };
        return SabloTabseq;
    }());
    SabloTabseq.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: SabloTabseq, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    SabloTabseq.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.2", type: SabloTabseq, selector: "[sabloTabseq]", inputs: { designTabSeq: ["sabloTabseq", "designTabSeq"], config: ["sabloTabseqConfig", "config"] }, host: { listeners: { "registerCSTS": "registerChildHandler($event.detail[0],$event.detail[1],$event)", "unregisterCSTS": "unregisterChildHandler($event.detail[0],$event.detail[1],$event)", "recalculatePSTS": "recalculateIndexesHandler($event.detail[0],$event.detail[1],$event)", "disableTabseq": "disableTabseq($event)", "enableTabseq": "enableTabseq($event)" }, properties: { "attr.tabindex": "this.tabindex" } }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: SabloTabseq, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[sabloTabseq]'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { designTabSeq: [{
                    type: i0.Input,
                    args: ['sabloTabseq']
                }], config: [{
                    type: i0.Input,
                    args: ['sabloTabseqConfig']
                }], tabindex: [{
                    type: i0.HostBinding,
                    args: ['attr.tabindex']
                }], registerChildHandler: [{
                    type: i0.HostListener,
                    args: ['registerCSTS', ['$event.detail[0]', '$event.detail[1]', '$event']]
                }], unregisterChildHandler: [{
                    type: i0.HostListener,
                    args: ['unregisterCSTS', ['$event.detail[0]', '$event.detail[1]', '$event']]
                }], recalculateIndexesHandler: [{
                    type: i0.HostListener,
                    args: ['recalculatePSTS', ['$event.detail[0]', '$event.detail[1]', '$event']]
                }], disableTabseq: [{
                    type: i0.HostListener,
                    args: ['disableTabseq', ['$event']]
                }], enableTabseq: [{
                    type: i0.HostListener,
                    args: ['enableTabseq', ['$event']]
                }] } });

    var SpecTypesService = /** @class */ (function () {
        function SpecTypesService(logFactory) {
            this.registeredTypes = new Map();
            this.log = logFactory.getLogger('SpecTypesService');
        }
        SpecTypesService.prototype.createType = function (name) {
            var classRef = this.registeredTypes.get(name);
            if (classRef) {
                return new classRef();
            }
            this.log.warn('returning just the basic custom object for  ' + name + ' none of the properties will be monitored');
            return new BaseCustomObject();
        };
        SpecTypesService.prototype.enhanceArrayType = function (array, iterableDiffers) {
            if (!instanceOfChangeAwareValue(array)) {
                array['stateHolder'] = new ArrayState(array, iterableDiffers);
                Object.defineProperty(array, 'getStateHolder', {
                    enumerable: false,
                    value: function () {
                        return this.stateHolder;
                    }
                });
                Object.defineProperty(array, 'markForChanged', {
                    enumerable: false,
                    value: function () {
                        this.stateHolder.notifyChangeListener();
                    }
                });
                array['stateHolder'].initDiffer();
            }
            return array;
        };
        SpecTypesService.prototype.registerType = function (name, classRef) {
            this.registeredTypes.set(name, classRef);
        };
        SpecTypesService.prototype.guessType = function (val) {
            var guess = null;
            if (instanceOfCustomArray(val)) {
                guess = 'JSON_arr';
            }
            else if (instanceOfBaseCustomObject(val)) {
                guess = 'JSON_obj';
            } // else TODO do any other types need guessing?
            //        else { // try to find it in types?
            //            this.registeredTypes.forEach(function(typeConstructorValue, typeNameKey) {
            //                if (val instanceof typeConstructorValue) guess = typeNameKey; // this wouldn't return the converter name like 'JSON_obj' but rather the actual name from spec
            //                of the custom type like "(...).tab"
            //            });
            //        }
            return guess;
        };
        return SpecTypesService;
    }());
    SpecTypesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: SpecTypesService, deps: [{ token: LoggerFactory }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    SpecTypesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: SpecTypesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: SpecTypesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }], ctorParameters: function () { return [{ type: LoggerFactory }]; } });
    function isChanged(now, prev, conversionInfo) {
        if ((typeof conversionInfo === 'string' || typeof conversionInfo === 'number') && instanceOfChangeAwareValue(now)) {
            return now.getStateHolder().hasChanges();
        }
        if (now === prev)
            return false;
        if (now && prev) {
            if (now instanceof Array) {
                if (prev instanceof Array) {
                    if (now.length !== prev.length)
                        return true;
                }
                else {
                    return true;
                }
            }
            if (now instanceof Date) {
                if (prev instanceof Date) {
                    return now.getTime() !== prev.getTime();
                }
                return true;
            }
            if ((now instanceof Object) && (prev instanceof Object)) {
                // first build up a list of all the properties both have.
                var fulllist = this.getCombinedPropertyNames(now, prev);
                for (var prop in fulllist) {
                    // ng repeat creates a child scope for each element in the array any scope has a $$hashKey property which must be ignored since it is not part of the model
                    if (prev[prop] !== now[prop]) {
                        if (prop === '$$hashKey')
                            continue;
                        if (typeof now[prop] === 'object') {
                            if (isChanged(now[prop], prev[prop], conversionInfo ? conversionInfo[prop] : undefined)) {
                                return true;
                            }
                        }
                        else {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
        return true;
    }
    var instanceOfChangeAwareValue = function (obj) { return obj != null && (obj).getStateHolder instanceof Function; };
    var instanceOfCustomArray = function (obj) { return instanceOfChangeAwareValue(obj) && obj.markForChanged instanceof Function; };
    var instanceOfBaseCustomObject = function (obj) { return instanceOfChangeAwareValue(obj) && (obj).getStateHolder() instanceof BaseCustomObjectState; };
    exports.ChangeType = void 0;
    (function (ChangeType) {
        ChangeType[ChangeType["ROWS_CHANGED"] = 0] = "ROWS_CHANGED";
        /**
         * When an INSERT happened but viewport size remained the same, it is
         * possible that some of the rows that were previously at the end of the viewport
         * slided out of it;
         * NOTE: insert signifies an insert into the client viewport, not necessarily
         * an insert in the foundset itself; for example calling "loadExtraRecordsAsync"
         * can result in an insert notification + bigger viewport size notification
         */
        ChangeType[ChangeType["ROWS_INSERTED"] = 1] = "ROWS_INSERTED";
        /**
         * When a DELETE happened inside the viewport but there were more rows available in the
         * foundset after current viewport, it is possible that some of those rows
         * slided into the viewport;
         * NOTE: delete signifies a delete from the client viewport, not necessarily
         * a delete in the foundset itself; for example calling "loadLessRecordsAsync" can
         * result in a delete notification + smaller viewport size notification
         */
        ChangeType[ChangeType["ROWS_DELETED"] = 2] = "ROWS_DELETED";
    })(exports.ChangeType || (exports.ChangeType = {}));
    var BaseCustomObject = /** @class */ (function () {
        function BaseCustomObject() {
            this.state = new BaseCustomObjectState();
            this.state.allChanged = true;
        }
        BaseCustomObject.prototype.getStateHolder = function () {
            return this.state;
        };
        /**
         *  subclasses can override this to give back the properties that needs to be watched.
         */
        BaseCustomObject.prototype.getWatchedProperties = function () {
            return null;
        };
        return BaseCustomObject;
    }());
    ;
    var ChangeAwareState = /** @class */ (function () {
        function ChangeAwareState() {
            this.allChanged = false;
            this.inNotify = false;
        }
        ChangeAwareState.prototype.markAllChanged = function (notifyListener) {
            this.allChanged = true;
            if (notifyListener)
                this.notifyChangeListener();
        };
        ChangeAwareState.prototype.hasChanges = function () {
            return this.allChanged || this.inNotify;
        };
        ChangeAwareState.prototype.setChangeListener = function (callback) {
            this.changeListener = callback;
        };
        ChangeAwareState.prototype.notifyChangeListener = function () {
            this.inNotify = true;
            if (this.changeListener)
                this.changeListener();
            this.inNotify = false;
        };
        return ChangeAwareState;
    }());
    var BaseCustomObjectState = /** @class */ (function (_super) {
        __extends(BaseCustomObjectState, _super);
        function BaseCustomObjectState() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.conversionInfo = {};
            _this.ignoreChanges = false;
            _this.change = 0;
            _this.hash = BaseCustomObjectState.counter++;
            _this.changedKeys = new Set();
            return _this;
        }
        BaseCustomObjectState.prototype.hasChanges = function () {
            return _super.prototype.hasChanges.call(this) || this.getChangedKeys().size > 0; // leave this as a method call as some subclasses might compute the changedKeys inside getChangedKeys()
        };
        BaseCustomObjectState.prototype.setPropertyAndHandleChanges = function (_thisBaseCustoomObject, internalPropertyName, propertyName, value) {
            var _this = this;
            var oldValue = _thisBaseCustoomObject[internalPropertyName];
            // if the value of this property is changed, mark it as such and notify if needed
            this.markIfChanged(propertyName, value, oldValue);
            // unregister as listener to old value if needed
            this.setChangeListenerToSubValueIfNeeded(oldValue, undefined);
            _thisBaseCustoomObject[internalPropertyName] = value;
            // register as listener to new value if needed
            this.setChangeListenerToSubValueIfNeeded(value, function () {
                _this.markIfChanged(propertyName, value, value);
            });
            // this value has changed by reference; so it needs to be fully sent to server - except for when it now arrived from the server and is being set (in which case ignoreChanges is true)
            if (!this.ignoreChanges && instanceOfChangeAwareValue(value))
                value.getStateHolder().markAllChanged(false);
        };
        BaseCustomObjectState.prototype.getChangedKeys = function () {
            return this.changedKeys;
        };
        BaseCustomObjectState.prototype.clearChanges = function () {
            this.changedKeys.clear();
            this.allChanged = false;
        };
        BaseCustomObjectState.prototype.getHashKey = function () {
            return this.hash + '_' + this.change;
        };
        BaseCustomObjectState.prototype.markIfChanged = function (propertyName, newObject, oldObject) {
            if (this.testChanged(propertyName, newObject, oldObject)) {
                this.pushChange(propertyName);
                return true;
            }
            return false;
        };
        BaseCustomObjectState.prototype.setChangeListenerToSubValueIfNeeded = function (value, changeListener) {
            if (instanceOfChangeAwareValue(value)) {
                // child is able to handle it's own change mechanism
                value.getStateHolder().setChangeListener(changeListener);
            }
        };
        BaseCustomObjectState.prototype.pushChange = function (propertyName) {
            if (this.ignoreChanges)
                return;
            if (this.changedKeys.size === 0)
                this.change++;
            if (!this.changedKeys.has(propertyName)) {
                this.changedKeys.add(propertyName);
                this.notifyChangeListener();
            }
        };
        BaseCustomObjectState.prototype.testChanged = function (propertyName, newObject, oldObject) {
            if (newObject !== oldObject)
                return true;
            if (typeof newObject == 'object') {
                if (instanceOfChangeAwareValue(newObject)) {
                    return newObject.getStateHolder().hasChanges();
                }
                else {
                    return isChanged(newObject, oldObject, this.conversionInfo[propertyName]);
                }
            }
            return false;
        };
        return BaseCustomObjectState;
    }(ChangeAwareState));
    // provide a hash that lets arrays that contain custom objects know that the object has changed or not
    BaseCustomObjectState.counter = 0;
    var ArrayState = /** @class */ (function (_super) {
        __extends(ArrayState, _super);
        function ArrayState(array, iterableDiffers) {
            var _this = _super.call(this) || this;
            _this.array = array;
            _this.iterableDiffers = iterableDiffers;
            _this.allChanged = true;
            return _this;
        }
        ArrayState.prototype.initDiffer = function () {
            this.differ = this.iterableDiffers.find(this.array).create(function (index, item) {
                if (instanceOfBaseCustomObject(item)) {
                    return item.getStateHolder().getHashKey();
                }
                return item;
            });
            this.differ.diff(this.array);
        };
        ArrayState.prototype.clearChanges = function () {
            _super.prototype.clearChanges.call(this);
            this.initDiffer();
        };
        ArrayState.prototype.getChangedKeys = function () {
            var changes = _super.prototype.getChangedKeys.call(this);
            var arrayChanges = this.differ.diff(this.array);
            if (arrayChanges) {
                var addedOrRemoved_1 = 0;
                arrayChanges.forEachAddedItem(function (record) {
                    addedOrRemoved_1++;
                    changes.add(record.currentIndex);
                });
                arrayChanges.forEachRemovedItem(function (record) {
                    addedOrRemoved_1--;
                    changes.add(record.previousIndex);
                });
                arrayChanges.forEachMovedItem(function (record) {
                    if (instanceOfChangeAwareValue(record.item)) {
                        return record.item.getStateHolder().markAllChanged(false);
                    }
                });
                if (addedOrRemoved_1 !== 0) {
                    // size changed, for now send whole array
                    this.markAllChanged(false);
                }
                else {
                    var changesArray = Array.from(changes);
                    changesArray.sort(function (a, b) { return a - b; });
                    changes = new Set(changesArray);
                }
            }
            return changes;
        };
        return ArrayState;
    }(BaseCustomObjectState));
    ;

    var ServoyPublicModule = /** @class */ (function () {
        function ServoyPublicModule() {
        }
        return ServoyPublicModule;
    }());
    ServoyPublicModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ServoyPublicModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicModule, declarations: [TooltipDirective,
            MnemonicletterFilterPipe,
            NotNullOrEmptyPipe,
            HtmlFilterPipe,
            FormatDirective,
            DecimalkeyconverterDirective,
            FormatFilterPipe,
            EmptyValueFilterPipe,
            StartEditDirective,
            ImageMediaIdDirective,
            AutosaveDirective,
            UploadDirective,
            SabloTabseq,
            TrustAsHtmlPipe], exports: [TooltipDirective,
            MnemonicletterFilterPipe,
            NotNullOrEmptyPipe,
            HtmlFilterPipe,
            FormatDirective,
            DecimalkeyconverterDirective,
            FormatFilterPipe,
            EmptyValueFilterPipe,
            StartEditDirective,
            ImageMediaIdDirective,
            AutosaveDirective,
            UploadDirective,
            SabloTabseq,
            TrustAsHtmlPipe] });
    ServoyPublicModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicModule, providers: [TooltipService, FormattingService, ComponentContributor, SpecTypesService, WindowRefService, LoggerFactory], imports: [[]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [TooltipDirective,
                            MnemonicletterFilterPipe,
                            NotNullOrEmptyPipe,
                            HtmlFilterPipe,
                            FormatDirective,
                            DecimalkeyconverterDirective,
                            FormatFilterPipe,
                            EmptyValueFilterPipe,
                            StartEditDirective,
                            ImageMediaIdDirective,
                            AutosaveDirective,
                            UploadDirective,
                            SabloTabseq,
                            TrustAsHtmlPipe
                        ],
                        imports: [],
                        exports: [TooltipDirective,
                            MnemonicletterFilterPipe,
                            NotNullOrEmptyPipe,
                            HtmlFilterPipe,
                            FormatDirective,
                            DecimalkeyconverterDirective,
                            FormatFilterPipe,
                            EmptyValueFilterPipe,
                            StartEditDirective,
                            ImageMediaIdDirective,
                            AutosaveDirective,
                            UploadDirective,
                            SabloTabseq,
                            TrustAsHtmlPipe
                        ],
                        providers: [TooltipService, FormattingService, ComponentContributor, SpecTypesService, WindowRefService, LoggerFactory]
                    }]
            }] });

    var scrollbarConstants = {
        SCROLLBARS_WHEN_NEEDED: 0,
        VERTICAL_SCROLLBAR_AS_NEEDED: 1,
        VERTICAL_SCROLLBAR_ALWAYS: 2,
        VERTICAL_SCROLLBAR_NEVER: 4,
        HORIZONTAL_SCROLLBAR_AS_NEEDED: 8,
        HORIZONTAL_SCROLLBAR_ALWAYS: 16,
        HORIZONTAL_SCROLLBAR_NEVER: 32
    };
    var PropertyUtils = /** @class */ (function () {
        function PropertyUtils() {
        }
        PropertyUtils.setHorizontalAlignment = function (element, renderer, halign) {
            if (halign !== -1) {
                if (halign === 0) {
                    renderer.setStyle(element, 'text-align', 'center');
                }
                else if (halign === 4) {
                    renderer.setStyle(element, 'text-align', 'right');
                }
                else {
                    renderer.setStyle(element, 'text-align', 'left');
                }
            }
        };
        PropertyUtils.setRotation = function (element, renderer, rotation, size) {
            var r = 'rotate(' + rotation + 'deg)';
            renderer.setStyle(element, '-moz-transform', r);
            renderer.setStyle(element, '-webkit-transform', r);
            renderer.setStyle(element, '-o-transform', r);
            renderer.setStyle(element, '-ms-transform', r);
            renderer.setStyle(element, 'transform', r);
            renderer.setStyle(element, 'position', 'absolute');
            if (rotation === 90 || rotation === 270) {
                renderer.setStyle(element, 'width', size.height + 'px');
                renderer.setStyle(element, 'height', size.width + 'px');
                renderer.setStyle(element, 'left', (size.width - size.height) / 2 + 'px');
                renderer.setStyle(element, 'top', (size.height - size.width) / 2 + 'px');
            }
        };
        PropertyUtils.setBorder = function (element, renderer, newVal) {
            var e_1, _a, e_2, _b;
            if (typeof newVal !== 'object' || newVal == null) {
                renderer.removeStyle(element, 'border');
                return;
            }
            if (renderer.parentNode(element).nodeName === 'FIELDSET') {
                // unwrap fieldset
                var parent = renderer.parentNode(element);
                renderer.insertBefore(renderer.parentNode(parent), element, parent);
                renderer.removeChild(renderer.parentNode(parent), parent);
            }
            if (newVal.type === 'TitledBorder') {
                var fieldset = renderer.createElement('fieldset');
                renderer.setAttribute(fieldset, 'style', 'padding:1px;margin:0px;border:1px solid silver;width:100%;height:100%');
                var legend = renderer.createElement('legend');
                renderer.setAttribute(legend, 'style', 'border-bottom:0px; margin:0px;width:auto;color:' + newVal.color + ';text-align:' + newVal.titleJustification);
                if (newVal.font) {
                    try {
                        for (var _c = __values(Object.keys(newVal.font)), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var key = _d.value;
                            // keys like 'fontSize' need to be converted into 'font-size'
                            renderer.setStyle(legend, key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(), newVal.font[key]);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                renderer.appendChild(legend, renderer.createText(newVal.title));
                // this is the way it is done in the old ngclient, but the actual component is positioned partially outside the border
                //            var parent = renderer.parentNode(element);
                //            renderer.insertBefore(parent, fieldset, element);
                //            renderer.appendChild(fieldset, legend);
                //            renderer.appendChild(fieldset, element);
                renderer.appendChild(fieldset, legend);
                for (var i in element.childNodes) {
                    if (element.childNodes[i].nodeType === 1) {
                        renderer.appendChild(fieldset, element.childNodes[i]);
                    }
                }
                renderer.appendChild(element, fieldset);
            }
            else if (newVal.borderStyle) {
                renderer.removeStyle(element, 'border');
                try {
                    for (var _e = __values(Object.keys(newVal.borderStyle)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var key = _f.value;
                        renderer.setStyle(element, key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(), newVal.borderStyle[key]);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        PropertyUtils.setFont = function (element, renderer, newVal) {
            var e_3, _a;
            if (typeof newVal !== 'object' || newVal == null) {
                renderer.removeStyle(element, 'font');
                return;
            }
            renderer.removeStyle(element, 'font');
            try {
                for (var _b = __values(Object.keys(newVal)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    renderer.setStyle(element, key, newVal[key]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        };
        PropertyUtils.setVisible = function (element, renderer, newVal) {
            var correctElement = element;
            if (renderer.parentNode(renderer.parentNode(element)) === element.closest('.svy-wrapper')) {
                correctElement = renderer.parentNode(renderer.parentNode(element));
            }
            if (newVal === true) {
                // can we improve this ?
                renderer.removeStyle(correctElement, 'display');
            }
            else if (newVal === false) {
                renderer.setStyle(correctElement, 'display', 'none');
            }
        };
        PropertyUtils.addSelectOnEnter = function (element, renderer, doc) {
            renderer.listen(element, 'focus', function () {
                setTimeout(function () {
                    // this access "document" directly which shoudn't really be done, but angular doesn't have encapsuled support for testing "is(":focus")"
                    var currentFocusedElement = doc.querySelector(':focus');
                    if (currentFocusedElement === element)
                        element.select();
                }, 0);
            });
        };
        PropertyUtils.getScrollbarsStyleObj = function (scrollbars) {
            var style = {};
            /* eslint-disable no-bitwise */
            if ((scrollbars & scrollbarConstants.HORIZONTAL_SCROLLBAR_NEVER) === scrollbarConstants.HORIZONTAL_SCROLLBAR_NEVER) {
                style['overflowX'] = 'hidden';
            }
            else if ((scrollbars & scrollbarConstants.HORIZONTAL_SCROLLBAR_ALWAYS) === scrollbarConstants.HORIZONTAL_SCROLLBAR_ALWAYS) {
                style['overflowX'] = 'scroll';
            }
            else {
                style['overflowX'] = 'auto';
            }
            if ((scrollbars & scrollbarConstants.VERTICAL_SCROLLBAR_NEVER) === scrollbarConstants.VERTICAL_SCROLLBAR_NEVER) {
                style['overflowY'] = 'hidden';
            }
            else if ((scrollbars & scrollbarConstants.VERTICAL_SCROLLBAR_ALWAYS) === scrollbarConstants.VERTICAL_SCROLLBAR_ALWAYS) {
                style['overflowY'] = 'scroll'; // $NON-NLS-1$
            }
            else {
                style['overflowY'] = 'auto'; // $NON-NLS-1$
            }
            /* eslint-enable no-bitwise */
            return style;
        };
        PropertyUtils.setScrollbars = function (element, renderer, value) {
            var style = this.getScrollbarsStyleObj(value);
            Object.keys(style).forEach(function (key) {
                renderer.setStyle(element, key, style[key]);
            });
        };
        // internal function
        PropertyUtils.getPropByStringPath = function (o, s) {
            s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
            s = s.replace(/^\./, ''); // strip a leading dot
            var a = s.split('.');
            while (a.length) {
                var n = a.shift();
                if (n in o) {
                    o = o[n];
                }
                else {
                    return;
                }
                return o;
            }
        };
        return PropertyUtils;
    }());

    /**
     * Returns a zero-based index for first day of the week, as used by the specified locale
     * e.g. Sunday (returns 0), or Monday (returns 1)
     *
     * @param locale
     * @returns
     */
    var getFirstDayOfWeek = function (locale) {
        // from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
        var firstDay = {
            bd: 5,
            mv: 5,
            ae: 6,
            af: 6,
            bh: 6,
            dj: 6,
            dz: 6,
            eg: 6,
            iq: 6,
            ir: 6,
            jo: 6,
            kw: 6,
            ly: 6,
            ma: 6,
            om: 6,
            qa: 6,
            sa: 6,
            sd: 6,
            sy: 6,
            ye: 6,
            ag: 0,
            ar: 0,
            as: 0,
            au: 0,
            br: 0,
            bs: 0,
            bt: 0,
            bw: 0,
            by: 0,
            bz: 0,
            ca: 0,
            cn: 0,
            co: 0,
            dm: 0,
            do: 0,
            et: 0,
            gt: 0,
            gu: 0,
            hk: 0,
            hn: 0,
            id: 0,
            ie: 0,
            il: 0,
            in: 0,
            jm: 0,
            jp: 0,
            ke: 0,
            kh: 0,
            kr: 0,
            la: 0,
            mh: 0,
            mm: 0,
            mo: 0,
            mt: 0,
            mx: 0,
            mz: 0,
            ni: 0,
            np: 0,
            nz: 0,
            pa: 0,
            pe: 0,
            ph: 0,
            pk: 0,
            pr: 0,
            py: 0,
            sg: 0,
            sv: 0,
            th: 0,
            tn: 0,
            tt: 0,
            tw: 0,
            um: 0,
            us: 0,
            ve: 0,
            vi: 0,
            ws: 0,
            za: 0,
            zw: 0
        };
        var split = locale.split('-');
        var country = split.length > 1 ? split[1].toLowerCase() : split[0].toLowerCase();
        var dow = firstDay[country];
        return (dow === undefined) ? 1 : dow; /*Number*/
    };
    /**
     * Floors the specified date to the beginning of week.
     *
     * @param date
     * @returns
     */
    var floorToWeek = function (date) {
        var fd = getFirstDayOfWeek(date.locale);
        var day = date.weekday % 7; // convert to 0=sunday .. 6=saturday
        var dayAdjust = day >= fd ? -day + fd : -day + fd - 7;
        return date.plus({ days: dayAdjust });
    };

    var ServoyPublicServiceTestingImpl = /** @class */ (function (_super) {
        __extends(ServoyPublicServiceTestingImpl, _super);
        function ServoyPublicServiceTestingImpl() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.messages = {};
            _this.forms = {};
            return _this;
        }
        ServoyPublicServiceTestingImpl.prototype.addForm = function (name, formCache) {
            this.forms[name] = formCache;
        };
        ServoyPublicServiceTestingImpl.prototype.getFormCacheByName = function (containedForm) {
            if (this.forms[containedForm])
                return this.forms[containedForm];
            var form = {
                absolute: true,
                size: { width: 100, height: 100 },
                getComponent: function (name) {
                    var comp = {
                        name: name,
                        model: {}
                    };
                    return comp;
                }
            };
            return form;
        };
        ServoyPublicServiceTestingImpl.prototype.generateServiceUploadUrl = function (serviceName, apiFunctionName) {
            return 'resources/upload/1/svy_services/' + serviceName + '/' + apiFunctionName;
        };
        ServoyPublicServiceTestingImpl.prototype.generateUploadUrl = function (formname, componentName, propertyName) {
            return 'resources/upload/1' +
                (formname ? '/' + formname : '') +
                (componentName ? '/' + componentName : '') +
                (propertyName ? '/' + propertyName : '');
        };
        ServoyPublicServiceTestingImpl.prototype.executeInlineScript = function (formname, script, params) {
            throw new Error('Method not implemented.');
        };
        ServoyPublicServiceTestingImpl.prototype.addMessage = function (key, message) {
            this.messages[key] = message;
        };
        ServoyPublicServiceTestingImpl.prototype.getI18NMessages = function () {
            var _this = this;
            var keys = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                keys[_i] = arguments[_i];
            }
            var resolvedMessages = {};
            keys.forEach(function (key) { return resolvedMessages[key] = _this.messages[key] ? _this.messages[key] : ''; });
            return Promise.resolve(resolvedMessages);
        };
        ServoyPublicServiceTestingImpl.prototype.callService = function (serviceName, methodName, argsObject, async) {
            throw new Error('Method not implemented.');
        };
        ServoyPublicServiceTestingImpl.prototype.setLocale = function (locale) {
            this.locale = locale;
        };
        ServoyPublicServiceTestingImpl.prototype.getLocale = function () {
            return this.locale ? this.locale : 'en';
        };
        ServoyPublicServiceTestingImpl.prototype.createJSEvent = function (event, eventType, contextFilter, contextFilterElement) {
            var ev = new JSEvent();
            ev.eventType = eventType;
            ev.svyType = eventType;
            ev.formName = 'test';
            ev.elementName = 'test';
            ev.timestamp = new Date().getTime();
            return ev;
        };
        ServoyPublicServiceTestingImpl.prototype.showFileOpenDialog = function (title, multiselect, acceptFilter, url) {
            throw new Error('Method not implemented.');
        };
        return ServoyPublicServiceTestingImpl;
    }(ServoyPublicService));
    ServoyPublicServiceTestingImpl.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicServiceTestingImpl, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ServoyPublicServiceTestingImpl.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicServiceTestingImpl });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicServiceTestingImpl, decorators: [{
                type: i0.Injectable
            }] });
    var ServoyPublicTestingModule = /** @class */ (function () {
        function ServoyPublicTestingModule() {
        }
        return ServoyPublicTestingModule;
    }());
    ServoyPublicTestingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicTestingModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    ServoyPublicTestingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicTestingModule, imports: [ServoyPublicModule], exports: [ServoyPublicModule] });
    ServoyPublicTestingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicTestingModule, providers: [
            ServoyPublicServiceTestingImpl, { provide: ServoyPublicService, useExisting: ServoyPublicServiceTestingImpl }
        ], imports: [[
                ServoyPublicModule
            ], ServoyPublicModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0__namespace, type: ServoyPublicTestingModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [],
                        imports: [
                            ServoyPublicModule
                        ],
                        exports: [
                            ServoyPublicModule
                        ],
                        providers: [
                            ServoyPublicServiceTestingImpl, { provide: ServoyPublicService, useExisting: ServoyPublicServiceTestingImpl }
                        ],
                        schemas: []
                    }]
            }] });

    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function runOnPushChangeDetection(cf) {
        return __awaiter(this, void 0, void 0, function () {
            var cd;
            return __generator(this, function (_a) {
                cd = cf.debugElement.injector.get(i0.ChangeDetectorRef);
                cd.detectChanges();
                return [2 /*return*/, cf.whenStable()];
            });
        });
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ArrayState = ArrayState;
    exports.AutosaveDirective = AutosaveDirective;
    exports.BaseCustomObject = BaseCustomObject;
    exports.BaseCustomObjectState = BaseCustomObjectState;
    exports.ChangeAwareState = ChangeAwareState;
    exports.ComponentContributor = ComponentContributor;
    exports.DecimalkeyconverterDirective = DecimalkeyconverterDirective;
    exports.Deferred = Deferred;
    exports.EmptyValueFilterPipe = EmptyValueFilterPipe;
    exports.Format = Format;
    exports.FormatDirective = FormatDirective;
    exports.FormatFilterPipe = FormatFilterPipe;
    exports.FormattingService = FormattingService;
    exports.HtmlFilterPipe = HtmlFilterPipe;
    exports.ImageMediaIdDirective = ImageMediaIdDirective;
    exports.JSEvent = JSEvent;
    exports.LogConfiguration = LogConfiguration;
    exports.LoggerFactory = LoggerFactory;
    exports.LoggerService = LoggerService;
    exports.MnemonicletterFilterPipe = MnemonicletterFilterPipe;
    exports.NotNullOrEmptyPipe = NotNullOrEmptyPipe;
    exports.PropertyUtils = PropertyUtils;
    exports.SabloTabseq = SabloTabseq;
    exports.ServoyApi = ServoyApi;
    exports.ServoyBaseComponent = ServoyBaseComponent;
    exports.ServoyPublicModule = ServoyPublicModule;
    exports.ServoyPublicService = ServoyPublicService;
    exports.ServoyPublicServiceTestingImpl = ServoyPublicServiceTestingImpl;
    exports.ServoyPublicTestingModule = ServoyPublicTestingModule;
    exports.SpecTypesService = SpecTypesService;
    exports.StartEditDirective = StartEditDirective;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipService = TooltipService;
    exports.TrustAsHtmlPipe = TrustAsHtmlPipe;
    exports.UploadDirective = UploadDirective;
    exports.WindowRefService = WindowRefService;
    exports.floorToWeek = floorToWeek;
    exports.getFirstDayOfWeek = getFirstDayOfWeek;
    exports.instanceOfBaseCustomObject = instanceOfBaseCustomObject;
    exports.instanceOfChangeAwareValue = instanceOfChangeAwareValue;
    exports.instanceOfCustomArray = instanceOfCustomArray;
    exports.isChanged = isChanged;
    exports.runOnPushChangeDetection = runOnPushChangeDetection;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=servoy-public.umd.js.map
